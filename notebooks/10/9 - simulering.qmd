---
title: '[< Forrige](8%20-%20sympy.ipynb)     |     <span style="color:lightgrey">Neste></span>'
jupyter: python3
---



<span style="color:#9bb1d4;font-size:30px;font-weight:900"> 9 - Simuleringer </span>  

### Simulering ‚Äì Kombinasjon av "alt" üß†

Simulering er et kraftig verkt√∏y fordi det kombinerer nesten **alle konseptene** vi har dekket i kurset til n√•.

**Hvorfor simulering er viktig:**

* **Variabler, Funksjoner & Lister/Dictionaries:** Brukes til √• definere input, lagre data og bygge de logiske stegene i modellen (f.eks. rente, startkapital, priser).
* **L√∏kker (`for`/`while`):** L√∏kker er selve *kjernen* i simulering, da de repeterer prosessen tusenvis av ganger.
* **NumPy:** Essensielt for √• h√•ndtere tilfeldigheter (`np.random`) og for raske, **vektoriserte** beregninger p√• store datamengder.
* **Pandas:** N√∏dvendig for √• organisere, strukturere og analysere de tusenvis av simuleringsresultatene p√• en effektiv m√•te.
* **Matplotlib:** Brukes for √• visualisere resultatene (f.eks. som et histogram) og si noe om modellen v√•r. Ved √• visualisere data, f√•r vi ofte bedre innsikt i hva som faktisk foreg√•r.

Simulering tvinger deg til √• **integrere** disse verkt√∏yene for √• l√∏se realistiske √∏konomiske problemer, som omhandler tema som usikkerhet og risiko.

# **Introduksjon til simulering**
L√∏kker er grunnsteinen i simulering. En simulering er en metode for √• etterligne den virkelige verden ved √• repetere en prosess mange ganger. Dette lar oss estimere usikre utfall, spesielt i finans og √∏konomi.

Vi starter med √• repetere for-l√∏kken, ettersom den brukes til √• repetere en handling et fast antall ganger.

## Eksempel 1: Rentes rente ‚Äì Kraften i repetisjon
Et sentralt √∏konomisk konsept er renters rente. Vi bruker en enkel `for`-l√∏kke til √• spore veksten i en investering over tid.

```{python}
# 1. Startparametere
startkapital = 10000  # Startbel√∏p i kroner
√•rlig_rente = 0.05   # 5% √•rlig rente
antall_√•r = 10

# Variabel for √• holde styr p√• kapitalen
kapital = startkapital

print(f"Kapital ved start (√Ör 0): {kapital:,.2f} kr")

# 2. Bruk en for-l√∏kke til √• simulere veksten √•r for √•r
for i in range(1, antall_√•r + 1):
    # Oppdater kapitalen: Kapital = Gammel_Kapital * (1 + Rente)
    kapital = kapital * (1 + √•rlig_rente)
    print(f"Kapital ved slutten av √•r {i}: {kapital:,.2f} kr")
```

# **Eksempel 2: Iterativ Modellering - Aksjekursen (Random Walk)**
Vi skal n√• bygge en enkel simulering av en aksjekurs ved hjelp av konseptet Random Walk (*tilfeldig gange* p√• d√•rlig oversatt norsk), der prisen i morgen er avhengig av prisen i dag pluss en tilfeldig endring.

Dette viser hvordan en simulering bygges steg for steg (iterativt).

```{python}
import numpy as np
import matplotlib.pyplot as plt

# 1. Startparametere
start_pris = 100
antall_dager = 252 # Antall handelsdager i et √•r
daglig_volatilitet = 0.01 # Standardavvik for daglig endring (1%)

# Lister for √• lagre resultatene
prisutvikling = [start_pris]
dager = [0]

# 2. Simuler prisutviklingen
for i in range(1, antall_dager + 1):
    # Generer en tilfeldig daglig endring (normalfordeling er ofte brukt) - mean=0, std=daglig_volatilitet
    endring = np.random.normal(loc=0, scale=daglig_volatilitet)
    
    # Ny pris = Gammel pris * (1 + Endring)
    ny_pris = prisutvikling[-1] * (1 + endring)
    
    # Lagre dataen
    prisutvikling.append(ny_pris)
    dager.append(i)

# 3. Visualiser resultatet
plt.figure(figsize=(10, 6))
plt.plot(dager, prisutvikling, label='Simulert Aksjekurs')
plt.title(f"Simulert Aksjekurs (Random Walk) over {antall_dager} dager")
plt.xlabel("Dager")
plt.ylabel("Pris (kr)")
plt.grid(True, linestyle='--', alpha=0.6)
plt.legend()
plt.show()
```

Plottet over vil vise forskjellig utfall for hver gang du kj√∏rer cellen. Det er fordi prisen avhenger av tidligere pris, med en tilfeldig komponent!

# Eksempel 3: While-l√∏kke for simulering av aksjekurs

En `while`-l√∏kke er en l√∏kke som fortsetter inntil en betingelse er oppfylt. I eksempelet under ser vi at det genereres nye tilfeldige aksjekurser s√• lenge kursen er under 125 kroner . 

Aksjen skal bevege seg tilfeldig. For √• f√• til det bruker vi funksjonen `rand` fra `random`-modulen i numpy.  `np.random.rand()` gir et tilfeldig tall mellom null og √©n, s√• ved √• multiplisere `(np.random.rand()-0.5)` med 40, f√•r vi et tilfeldig tall mellom -20 og 20. 

#### Eksempel 3:

```{python}
import numpy as np

dy = 0
y = 100

while y < 125:  
    y += dy
    dy = 40*(np.random.rand()-0.5) 
    print(y)
```

Legg spesielt merke til `y+=dy` over. Denne operasjonen legger `dy` til `y`, og tilsvarer alts√• `y=y+dy`. De aller fleste programmeringsspr√•k st√∏tter `+=`-operatoren.  

Legg ogs√• merke til at vi kan sette flere variabler samtidig, ved √• skille b√•de variablene og verdiene med like mange kommaer, `dy,y=0,100`

# Kraften av simulering üìä üìà üìâ

Simuleringer brukes i √∏konomi for √• modellere usikkerhet, teste hypoteser og analysere sannsynlige utfall.  
I denne notatboken skal vi utforske hvordan vi kan bruke Python til √• simulere √∏konomiske problemstillinger ved hjelp av tilfeldige tall og statistiske teknikker.

Vi vil se p√•:
- Generering av tilfeldige tall
- Monte Carlo-simuleringer
- Simulering av √∏konomiske prosesser, som prisutvikling og risikoanalyse

L√∏kker kan brukes til mye, s√• la oss se p√• et eksempel p√• simulering. 

Simulering vil si √• trekke tilfeldige tall for √• se hvordan en modell opptrer under usikkerhet. 
## Simulering av aksjekurs üíπ

I denne simuleringen antar vi at en aksjekurs starter p√• 100 kr og beveger seg tilfeldig over tid.  
Vi observerer aksjen hvert sjette minutt, eller √©n tidel (0.1) av en time. Tiden √∏ker dermed med 0.1 i hver periode. 

For √• tegne opp stien til aksjekursen, lager vi f√∏rst lister for x- og y-verdiene, og s√• legger vi til elementer i hver av listene med `append`-funksjonen til listeobjektene, f√∏r listen plottes som en graf. Kj√∏r koden flere ganger, for √• se ulike simuleringer. 

#### Eksempel 4:

```{python}
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Ellipse
from IPython.display import display, clear_output

# Oppretter en figur og akse med en st√∏rrelse p√• 20x10 tommer
fig, ax = plt.subplots(figsize=(20, 10))

# Setter begrensninger for y- og x-aksen
ax.set_ylim([0,250])            # Y-aksen g√•r fra 0 til 250
ax.set_xlim([0,20])             # X-aksen g√•r fra 0 til 20

# Initierer med en rekke verdier (x = 0, y = 100, dy = 0)
x, y, dy = 0, 100, 0

# Lager tomme lister som vil lagre x- og y-posisjoner gjennom l√∏kka
ypath = []
xpath = []

# While-l√∏kka kj√∏rer s√• lenge x < 25, og for hvert steg √∏kes x med 0.1
while x < 25:
    x += 0.1            # √òker x med 0.1 for hvert steg
    y += dy             # Legger til dy til y-posisjonen (endrer y basert p√• dy)
    
    # Oppdaterer dy med en ny tilfeldig verdi som varierer mellom -20 og 20.
    # np.random.rand() gir en tilfeldig verdi mellom 0 og 1, 
    # s√• 40 * (np.random.rand() - 0.5) gir et tilfeldig tall mellom -20 og 20.
    # Dette gir y-posisjonen en tilfeldig variasjon ved hvert steg.
    dy = 40 * (np.random.rand() - 0.5)

    # Legger til de nye x- og y-verdiene i listene xpath og ypath
    xpath.append(x)
    ypath.append(y)

# Plotter banen for y-verdiene som funksjon av x, med etiketten 'YARA' (eksempel p√• et selskap)
ax.plot(xpath, ypath, label='YARA')

# Legger til en legende (forklaring) √∏verst til venstre p√• plottet
ax.legend(loc='upper left', frameon=False, fontsize=30)

# Viser plottet
plt.show()
```

## Simulering av stokastisk/tilfeldig bevegelse - forklaring av koden fra eksempel 4 

Denne koden simulerer en tilfeldig bevegelse over tid, som kan brukes til √• modellere aksjekurser eller andre √∏konomiske prosesser med usikkerhet.  

### üîπ Hvordan fungerer simuleringen?  
- Vi starter med en initial verdi **y = 100** og en tilfeldig endring **dy**.
- Hver iterasjon √∏ker **x** med **0.1**, og **y** justeres med en tilfeldig verdi.
- **dy** oppdateres tilfeldig mellom **-20 og 20**, slik at vi f√•r en tilfeldig variasjon i y-posisjonen.
- Bevegelsen plottes som en kurve, og resultatet viser hvordan verdien utvikler seg over tid.

### üîπ Forklaring av kode:
- **`ax.set_ylim([0,250])`** og **`ax.set_xlim([0,20])`** setter grensene for x- og y-aksen.
- **`while x < 25:`** s√∏rger for at simuleringen kj√∏rer til x n√•r 25.
- **`dy = 40 * (np.random.rand() - 0.5)`** genererer en tilfeldig endring mellom -20 og 20.
- **`ax.plot(xpath, ypath, label='YARA')`** tegner banen for den simulerte bevegelsen.

Kj√∏r koden flere ganger for √• se hvordan den tilfeldige bevegelsen varierer!

# Dynamisk plott üìâ

Om vi √∏nsker √• formidle kunnskap, er det av og til nyttig med dynamiske plott. Alts√• plott som endrer seg mens du ser p√• dem. Vi kan gj√∏re det ved √• rykke inn de to siste setningene fra Eksempel 4. 

Det er disse setningene som lager plottet. Ved √• rykke dem inn, plottes figuren i hver iterasjon. 

### üîπ Viktig √• merke seg:
- Uten **`clear_output(wait=True)`**, ville vi sett **25 separate figurer** i stedet for √©n dynamisk oppdatering. 
- I tillegg, s√• legger vi til at y-verdien ikke kan bli mindre enn $0$. Det gj√∏r vi her **`while x < 25 and y >=0`**.

Kj√∏r koden i Eksempel 5 og se hvordan den simulerte bevegelsen utvikler seg i sanntid! 

#### Eksempel 5:

```{python}
x, y, dy = 0, 100, 0

ypath = []
xpath = []

while x < 25 and y >=0:
    x += 0.1
    y += dy
    dy = 40 * (np.random.rand() - 0.5)

    xpath.append(x)
    ypath.append(y)
    
    # Ved √• plassere plot-funksjonen inne i l√∏kka, s√∏rger vi for at den plottes ved hver iterasjon
    ax.plot(xpath, ypath, label='YARA')
    ax.legend(loc='upper left', frameon=False, fontsize=30)
    
    # Jupyter viser som standard bare siste utsagn, s√• vi m√• legge til dette
    # for √• plotte p√• hver iterasjon
    display(fig)
    
    # S√∏rger for at plottet og utdataene blir slettet hver gang:
    ax.cla()
    ax.set_ylim([0, 400])
    ax.set_xlim([0, 20])
    clear_output(wait=True)
```

# Legge til litt effekter üîÑ

Det er ogs√• g√∏y med litt effekter n√•r vi skal formidle noe, bare det ikke blir s√• mye at det drar oppmerksomheten bort fra det vi skal formidle. I denne simuleringen er det veldig fristende √• lage en lite r√∏d prikk som "leder" aksjekursen videre. Vi skal ogs√• legge til en liten tekst som forteller hva aksjekursen er:

#### Eksempel 6:

```{python}
x, y, dy= 0, 100, 0

ypath=[]
xpath=[]

while x < 25 and y >= 0:
    x += 0.1
    y += dy
    dy = 40*(np.random.rand()-0.5)


    xpath.append(x)
    ypath.append(y)
    
    # Ved √• plassere plot-funksjonen inne i l√∏kka, s√∏rger vi for at den plottes ved hver iterasjon
    ax.plot(xpath,ypath,label='YARA')
    ax.legend(loc='upper left',frameon=False,fontsize=30)
    
    # Lager den r√∏d prikken
    c=Ellipse((x, y), 0.25,5, color='r')
    ax.add_patch(c)
    
    # Lager teksten ved siden av den r√∏de prikken
    ax.text(x+0.1,y+3,f'NOK {np.round(y,1)}')
    
    # Jupyter viser kun siste utsagn som standard, s√• vi m√• legge til dette
    # for √• plotte ved hver iterasjon
    display(fig)
    
    # S√∏rger for at plottet og utdataene blir slettet hver gang, og det ser ut som plottet oppdateres
    ax.cla()
    ax.set_ylim([0,800])
    ax.set_xlim([0,25])
    clear_output(wait = True)
```

# üî¢ Numerisk optimering  

Tidligere har vi funnet maksverdien av funksjoner ved √• bruke **Sympy** til √• derivere en funksjon, sette den lik null og l√∏se for $x$.  

Men hva om det er vanskelig √• finne den optimale l√∏sningen analytisk? (Noe det ofte kan v√¶re!) 

I slike tilfeller kan vi bruke **numerisk optimering**, der vi evaluerer objektfunksjonen (det vi √∏nsker √• maksimere) for mange ulike verdier og velger den beste.  

### Hva gj√∏r vi i dette eksemplet?  
Vi ser p√• en bedrift som selger $Q$ enheter av en vare til pris $p$, med en kostnad per enhet $C$.  
Bedriftens **fortjeneste** (profit) er gitt ved:  

$$p \cdot Q - C \cdot Q$$

Vi bruker numeriske metoder for √• finne verdien av $Q$ som maksimerer fortjenesten.  

Videre, antar vi at ettersp√∏rselfunksjonen (som bestemmer $Q$) er definert slik:

$$100 - p$$

Selv om vi i dette tilfellet enkelt kan finne maksimum analytisk med **Sympy**, kan vi bruke dette eksempelet for √• sjekke at den numeriske l√∏sningen er korrekt.  

Numerisk optimering er nyttig n√•r:
- Funksjonen er **komplisert** og vanskelig √• derivere.
- Vi har **diskrete verdier** der derivasjon ikke er praktisk.
- Vi √∏nsker √• **visualisere hvordan l√∏sningen varierer** over et bredt spekter av verdier.

La oss n√• implementere dette i Python i eksemplene under!

### Eksempel 7:

```{python}
# Definerer fortjenestefunksjonen, som avhenger av en ettersp√∏rsel.
def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q
```

Q bestemmes av en ettersp√∏rselfunksjon.

#### Eksempel 8

```{python}
# Definerer ettersp√∏rselfunksjonen
def demand(p):
    """Returnerer antall enheter solgt gitt en pris p."""
    return 100 - p
```

Vi kan n√• finne optimum numerisk, alts√• tallverdiene (optimal pris og hva maksimal profitt er ved denne optimale prisen.)

#### Eksempel 9:

```{python}
import numpy as np

def find_optimal_price(start, end, C):
    """Finner optimal pris i prisintervallet (start, end)"""
    max_profit = float('-inf')
    optimal_price = None
    n_samples = 1000
    
    # Itererer over pris-intervallet (start, end)
    for p in np.linspace(start, end, n_samples):
        current_profit = profit(p, C)
        if current_profit > max_profit:
            # Hvis 'profit' g√•r over 'current profit', s√• lagrer vi den nye 'profit' og pris
            max_profit = current_profit
            optimal_price = p

    return optimal_price, max_profit


cost = 5
start_price = 0
end_price = 100

optimal_price, max_profit = find_optimal_price(start_price, end_price, cost)

print(f"Optimal pris: {round(optimal_price, 2)} kr")
print(f"Maksimal profitt ved optimal pris: {round(max_profit, 2)} kr")
```

```{python}
### Vi visualiserer profit funksjonen over - for √• se om resultatet virker rimelig ###
import matplotlib.pyplot as plt
import numpy as np


# Kostnad per enhet ost, start_price og end_price (du kan justere denne verdien)
cost = 5
start_price = 0
end_price = 100

# Lag en array med pris (p) verdier fra 0 til 100
p_values = np.linspace(start_price, end_price, 500)

# Beregn profitt for hver pris-verdi (p)
profit_values = [profit(p, cost) for p in p_values]

# Plotter profittfunksjonen
plt.plot(p_values, profit_values, label="Profitt")
plt.title("Profitt som funksjon av pris", fontsize=14)
plt.xlabel("Pris (p)", fontsize=12)
plt.ylabel("Profitt", fontsize=12)
plt.ylim(0, 2500)  # Setter y-aksen fra 0 til 3000
plt.xlim(0, 100)   # Setter x-aksen fra 0 til 150
plt.axvline(x=optimal_price, color='red', linestyle='--', label=f'p = {round(optimal_price)}')
plt.legend()
plt.show()
```

Det ser ut som at optimal prisen p√• dr√∏ye $52$ passer godt til √• v√¶re optimalpris!

Vi kan verifisere dette enda en gang, ved hjelp av ```SymPy```.

#### Eksempel 10:

```{python}
import sympy as sp

# Definerer variabelen p (pris)
p = sp.Symbol('p')

# Kostnad C er satt til 30
C = 5

# Ettersp√∏rselsfunksjon
def demand(p):
    return 100 - p

def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q

# Deriverer profittfunksjonen med hensyn til p
profit_derivative = sp.diff(profit(p, C), p)

# Finn den optimale p-verdien ved √• l√∏se ligningen profit_derivative = 0
optimal_p = sp.solve(profit_derivative, p)

# Viser den optimale prisen
optimal_p_value = round(optimal_p[0], 2)
optimal_p_value
```

Her ser vi at SymPy gir at svaret er $52.5$ kr, mens simulering gjorde at vi fikk $52.45 \approx 52.5$ kr. Som viser styrken til begge metodene.

# Monte Carlo-simulering üñ•Ô∏è üé≤ üìä

Monte Carlo-simulering er en metode for √• estimere resultater ved hjelp av tilfeldige pr√∏ver.  
Denne teknikken er spesielt nyttig n√•r det er **usikkerhet** i dataene eller **mange mulige utfall**.  

### üîπ Hvorfor bruke Monte Carlo-simulering?  
- Mange √∏konomiske prosesser, som **investeringer og l√∏nnsvekst**, er usikre.  
- Deterministiske modeller fanger **ikke opp tilfeldigheter**, noe Monte Carlo-simulering gj√∏r.  
- Vi kan bruke denne teknikken for √• lage **sannsynlighetsfordelinger** og forutsi mulige utfall.  

I dette eksempelet ser vi p√• **inntektsutvikling** over tid, hvor inntekten hvert √•r avhenger av fjor√•ret.  
- **Vi starter med en gitt inntekt** og antar en √•rlig vekstrate (√©n prosent).  
- **Hvert √•r legges en tilfeldig variasjon til**, som representerer usikkerhet.  
- Vi kj√∏rer simuleringen mange ganger for √• se hvordan inntekten utvikler seg over tid.  

Vi starter med √• definere en funksjon som beregner neste √•rs inntekt, basert p√• fjor√•ret og et tilfeldig bidrag: 

#### Eksempel 11

```{python}
import numpy as np

def calc_income(last_year_income, growth_rate, volatility):
    # Tilfeldig vekst basert p√• normalfordeling
    random_growth = np.random.normal(0, volatility)
    
    # Total vekst er forventet vekst pluss tilfeldig vekst
    growth =  growth_rate + random_growth
    
    # Beregn √•rets inntekt
    income = round(last_year_income * (1 + growth))
    
    return income

# Her antar vi at fjor√•rets l√∏nn er 600.000kr, med 5% forventet inntekts√∏kning og 2% usikkerhet

print(f'Hvis fjor√•rets l√∏nn er 600.000 kr, s√• er √•rets l√∏nn {calc_income(600000, 0.05, 0.02)}, hvis vi har 5% forventet l√∏nns√∏kning og 2% usikkerhet.')
```

#### **S√• lager vi en funksjon som lager en "inntektssti" (income path) for et gitt antall √•rs inntekt. Dette kalles en "sti"/"path" fordi dagens inntekt er avhengig av g√•rsdagen. Dagens situasjon er alts√• avhengig av hvilken sti inntekten har fulgt i alle tidligere √•r.**

#### Eksempel 12

```{python}
def income_path(years, initial_income, growth_rate, volatility):
    
    incomes = [initial_income]
    
    # Simulerer en "inntektssti" over et gitt antall √•r
    for i in range(years):

        # Beregner inntekt for √•ret
        income = calc_income(incomes[-1], growth_rate, volatility)

        # Legger til inntekten i listen
        incomes.append(income)
        
    return incomes

#regner ut for fem √•r frem i tid:
income_path(5,600000, 0.05, 0.02)
```

#### **Vi kan n√• lage en funksjon som simulerer et gitt antall inntektsstier gitt ved `num_simulations`:**

#### Eksempel 13:

```{python}
import pandas as pd

def simulate_income(years, initial_income, growth_rate, volatility, num_simulations):
    """Returnerer en 2D-array med simulerte inntekter for hvert √•r."""
    # Starter med en tom liste, hvor vi skal fylle p√• med tall
    all_incomes = []
    for _ in range(num_simulations):
        # Legger til "the path" til variabelesn 'all_incomes'
        incomes = income_path(years, initial_income, growth_rate, volatility)
        all_incomes.append(incomes)

    # Setter inn i pandas DataFrame for √• f√• en visuelt, finere tabell
    return np.array(all_incomes)

# Simulerer 5 forskjellige inntektsbaner over 5 √•r
pd.DataFrame(simulate_income(5, 600000, 0.05, 0.02, 5))
```

#### **Vi kan n√• plotte fordelingen, for √• f√• et inntrykk av fordelingen til inntekten i avslutnings√•ret:**

#### Eksempel 14:

```{python}
import matplotlib.pyplot as plt

# Parametere
initial_income = 600000   # Start-inntekt
growth_rate = 0.03        # Forventet l√∏nnsvekst (prosent)
volatility = 0.02         # Volatilitet (usikkerhet)
years = 30                # Antall √•r
num_simulations = 1000    # Antall simuleringer

simulated_incomes = simulate_income(years, initial_income, growth_rate, volatility, num_simulations)

# plotting the final income
final_year_incomes = simulated_incomes[:, -1]

plt.hist(final_year_incomes, bins=50, edgecolor='black', alpha=0.75)
plt.gca().get_xaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
plt.xticks(rotation=90)
plt.title("Distribusjon av simulerte inntekter etter 30 √•r")
plt.xlabel("Inntekt")
plt.ylabel("Antall simuleringer")
plt.show()
```

### **Ekstra visualisering: Plotte flere inntektsstier**
Eksempel 14 (rett over), viser distribusjon (fordelingen) av simulerte inntekter etter $30$ √•r - hvor startinntekten var p√• $600 \; 000$ kr.

For √• vise hvordan ulike simuleringer utvikler seg over tid, kan vi legge til en graf som viser hvordan inntektsbanene utviklet seg.

Eksempel 15:

```{python}
plt.figure(figsize=(10, 5))

for i in range(1000):  # Plotter de 1000 inntektsstiene fra over
    plt.plot(simulated_incomes[i], alpha=0.5)

plt.title("Simulerte inntektsbaner over tid")
plt.xlabel("√Ör")
plt.ylabel("Inntekt (MNOK)")
plt.show()
```

## **Ekstra-Ekstra IKKE PENSUM, MEN KJEKT √Ö VITE OM**
Vi kan lage flotte plots, ved hjelp av noe som heter Plotly. Se kodeblokken under, for eksempel:

```{python}
import plotly.graph_objects as go

# Assuming simulated_incomes is already defined

fig = go.Figure()

# Lager en loop som g√•r igjennom de 10 f√∏rste simulerte inntekts-path'ene
for i in range(10):
    fig.add_trace(go.Scatter(
        x=list(range(2005, 2023)),  # √Örstall fra 2005 til 2022
        y=simulated_incomes[i],
        mode='lines',
        line=dict(width=2),  # Customize line width if needed
        opacity=0.5,  # Set the opacity for the lines
        name=f"Inntektssti nr. {i+1}" if i == 0 else None  # Only label the first line
    ))

# Oppdater layout
fig.update_layout(
    title="Simulerte inntektsbaner over tid",
    xaxis_title="√Ör",
    yaxis_title="Inntekt (MNOK)",
    showlegend=False
)

# Vis figuren
fig.show()
```

# Oppgaver

### Oppgave 1 - üìà Simulering av aksjekurs  
En aksjekurs beveger seg tilfeldig over tid. Vi antar at aksjen starter p√• **100 kroner** og endrer seg tilfeldig for hver tidsperiode.  

- **Lag en simulering av aksjekursen over 100 dager**  
- Hver dag endrer aksjekursen seg med en tilfeldig verdi mellom -3% og +3%  
- Plott kursutviklingen  

*Tips: Bruk en for-l√∏kke og lagre verdiene i en liste!* 

Bruk denne: `np.random.uniform(-0.03, 0.03)` 

Den gir tilfeldig tall mellom $-0.03$ og $0.03$.

Koden kan gjerne starte noe ala dette:

```python
# Parametere
days = 100
price = 100
prices = [price]

# Fortsett koden under - simulering og plotting
```

```{python}
import numpy as np
import matplotlib.pyplot as plt

# Parametere
days = 100
price = 100
prices = [price]
```

### Oppgave 2 - üè¢ Simulering av bedriftens overskudd 
En bedrift selger **Q** produkter til pris **p**, og produksjonskostnaden per enhet er **C**.  
Overskuddet beregnes som:  

$\text{Overskudd} = Q \cdot p - Q \cdot C$

**Lag en simulering der**:  
- **Q** varierer mellom 900 og 1100  
- **p** varierer mellom 90 og 110  
- **C** varierer mellom 50 og 70  

* Kj√∏r simuleringen **1000 ganger**  
* Plott histogram av overskuddet  

*Tips: Bruk numpy for √• generere tilfeldige verdier!*  


### Oppgave 3 - üí∞ Simulering av l√•nekostnader  
Du tar opp et boligl√•n p√• **2 000 000 kr**. Renten er i utgangspunktet **3%**, men den varierer tilfeldig mellom **2% og 5%** hvert √•r.  

- **Simuler utviklingen i l√•nekostnader over 30 √•r**  
- Beregn den totale rentekostnaden etter 30 √•r  
- Kj√∏r simuleringen **500 ganger**, og plott fordelingen av totale rentekostnader


### Oppgave 4 - üì¶ Simulering av lagerstyring og ettersp√∏rsel  
Et selskap h√•ndterer en vare med en ukentlig ettersp√∏rsel som varierer mellom **80 og 120 enheter**.  
De bestiller varer hver uke basert p√• en prognose, men **det er alltid en usikkerhet p√• ¬±10% i ettersp√∏rselen**.  

- **Simuler lagerbeholdning over 52 uker**  
- Start med et lager p√• **500 enheter**  
- Hvis lageret g√•r under **100 enheter**, bestilles **200 nye enheter**  
- Plott utviklingen i lagerbeholdning over tid


# Oppgave 5 - Simuleringer üí∞üé≤üí∞
Du er p√• tur med vennegjengen din p√• casino i Monaco, og spiller et (fiktivt) terningspill. 

Du vet at en vanlig terning f√∏lger en $\textit{diskret uniform fordeling}$, hvor det er like stor sannsynlighet for hvert $\textit{utfall}$ (alts√• om terningen viser $1, \; 2, \; 3, \; 4, \; 5$ eller $6$).

I statistikk, snakker vi ofte om $\textit{forventningsverdi}$ (skrives $E[X]$), som sier noe om hva vi forventer en tilfeldig variabel $X$ vil v√¶re. For diskret problemer er det definert som 
$$E[X] = \sum_{i=1}^{n}x_i \cdot P(X=x_i)$$

hvor $x_i$ er verdien av terningen, og $P(X=x_i)$ er sannsynligheten for √• f√• verdien $x_i$ p√• et kast. Vi vet at $n=6$, ettersom det er $6$ ulike utfall av en terning. Da kan vi skrive det ut slik:
$$E[X] = 1 \cdot \frac{1}{6} + 2 \cdot \frac{1}{6} + \cdots + 6 \cdot \frac{1}{6}$$
regner vi ut dette ser vi at vi f√•r
$$E[X] =3,5$$ 

Dermed er forventningsverdien til en terning lik $3,5$.

## Case
I dette fiktive terningsspillet i Monaco skal man trille to terninger, samtidig. Man vinner spillet hvis summen av de to terningene er *over eller lik* $9$. 
Du kommer p√• at du kan simulere utfall ved hjelp av Python og Numpy.

## Oppgave 5.1
Bruk simulering, til √• finne ut sannsynligheten for at du triller to treninger med sum $\textbf{over eller lik}$ $9$. 
- Visualiser utfallene ved bruk av et histogram.
- Antall simuleringer skal dere velge selv, men kommenter hvorfor dere velger som dere gj√∏r.
- Under er et lite kodehint for hva dere kan ta i bruk.
```python
        # Mulige bibliotek for oppgaven.
        import numpy as np
        import matplotlib.pyplot as plt
        import random

        # Du kan f√• bruk for funksjonen (hvor argumentene m√• spesifiseres i henhold til oppgaven). Hvor low = inkludert, high = ekskludert.
        np.random.randint(low, high=None, size=None, dtype=int)
```

## Oppgave 5.2
Finn ut hvor mange kast av to terninger m√• du ta ($n$) for at sannsynligheten for √• f√• en sum over eller lik $9$ minst √©n gang er over $90$%. 

Hint - formelen for √• finne sannsynligheten for at summen er over eller lik 9, minst √©n gang er gitt som f√∏lgende:
$$P(\text{summen} \geq 9 \text{ minst √©n gang}) = 1 - \left(P(\text{summen} < 9)\right)^n$$

hvor $P\left(\text{summen} < 9\right)$ kan finnes fra simuleringen over.

Bruk ```sympy``` for √• l√∏se dette problemet, og si hvor mange ganger ($n$) vi m√• trille terningen.



##### [< Forrige](6%20-%20pandas%2C%20filtrering%2C%20logikk%20og%20betingelser.ipynb)     |     <span style="color:lightgrey">Neste></span>

