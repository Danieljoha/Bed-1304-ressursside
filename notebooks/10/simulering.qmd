---
title: 9 - Simulering
jupyter: python3
---



Løkker er noe av det mest brukte verktøyet for en programmerer. En løkke er en programkode som repeteres, og det har vi gått igjennom tidligere i kurset. 

Det finnes i hovedsak to typer løkker i Python: `while`-løkker og `for`-løkker. En `while` lar løkken løpe til en betingelse er oppfylt, mens `for` løkken repeterer koden for alle elementene i en liste eller annen *iterativ datastruktur*. 

# For-løkker

Her er eksempel på en `for`-løkke som deriverer alle utrykkene i listen `expressions`:

#### Eksempel 1:
Vi har tidligere i kurset sett på ```sympy``` og derivasjon - dette kan vi også gjøre ved hjelp av en ```for```-løkke, for å iterere gjennom en liste. 

```{python}
from IPython.display import Markdown, display
import sympy as sp

x,y=sp.symbols("x y")

expressions=[
    sp.root(x,y),
    x**2+5*sp.exp(x),
    x*sp.ln(x)
]

for i in expressions:
    display(Markdown(f"Den deriverte av ${sp.latex(i)}$ er ${sp.latex(sp.diff(i,x))}$"))
```

#### Eksempel 2:
Eller du kan bare gjøre en enkel iterasjon for heltall fra en startverdi til en sluttverdi:

```{python}
for i in range(5,8):
    print(i)
    
for i in range(3):
    print(i)
```

Du kan også "pakke ut" elementer, dersom hvert element i `for`-setningen har et bestemt antall sub-elementer. La oss først lage en liste som inneholder en ´tuple´ med uttrykkene i `expressions` over, og den deriverte av disse:

#### Eksempel 3:

```{python}
#using list comprehension to generate a list with expression,derivative tuples:
expressions_w_derivatives=[ (i, sp.diff(i,x)) for i in expressions ]
expressions_w_derivatives
```

Vi kan nå kjøre en for-løkke som forventer at hvert element i listen er en *iterabel* (for eksempel liste eller tuple) med to elementer:

#### Eksempel 4

```{python}
for function,derivative in expressions_w_derivatives:
    display(Markdown(f"Den deriverte av ${sp.latex(function)}$ er ${sp.latex(derivative)}$"))
```

# While-løkker

En `while`-løkke er en løkke som fortsetter inntil en betingelse er oppfylt. I eksemplet under ser vi at det genereres nye tilfeldige aksjekurser så lenge kursen er under 125 kroner . 

Aksjen skal bevege seg tilfeldig. For å få til det bruker vi funksjonen `rand` fra `random`-modulen i numpy.  `np.random.rand()` gir et tilfeldig tall mellom null og én, så ved å multiplisere `(np.random.rand()-0.5)` med 40, får vi et tilfeldig tall mellom -20 og 20. 

#### Eksempel 5:

```{python}
import numpy as np

dy, y = 0, 100

while y < 125:  
    y += dy
    dy = 40*(np.random.rand()-0.5) 
    #print(y)
```

Legg spesielt merke til `y+=dy` over. Denne operasjonen legger `dy` til `y`, og tilsvarer altså `y=y+dy`. De aller fleste programmeringsspråk støtter `+=`-operatoren.  

Legg også merke til at vi kan sette flere variabler samtidig, ved å skille både variablene og verdiene med like mange kommaer, `dy,y=0,100`

# Dette leder oss inn på denne notatboken sitt tema - **Simuleringer** 📊 📈 📉

Simuleringer brukes i økonomi for å modellere usikkerhet, teste hypoteser og analysere sannsynlige utfall.  
I denne notatboken skal vi utforske hvordan vi kan bruke Python til å simulere økonomiske problemstillinger ved hjelp av tilfeldige tall og statistiske teknikker.

Vi vil se på:
- Generering av tilfeldige tall
- Monte Carlo-simuleringer
- Simulering av økonomiske prosesser, som prisutvikling og risikoanalyse

Løkker kan brukes til mye, så la oss se på et eksempel på simulering. 

Simulering vil si å trekke tilfeldige tall for å se hvordan en modell opptrer under usikkerhet. 
## Simulering av aksjekurs 💹

I denne simuleringen antar vi at en aksjekurs starter på 100 kr og beveger seg tilfeldig over tid.  
Vi observerer aksjen hvert sjette minutt, eller én tidel (0.1) av en time. Tiden øker dermed med 0.1 i hver periode. 

For å tegne opp stien til aksjekursen, lager vi først lister for x- og y-verdiene, og så legger vi til elementer i hver av listene med `append`-funksjonen til listeobjektene, før listen plottes som en graf. Kjør koden flere ganger, for å se ulike simuleringer. 

#### Eksempel 6:

```{python}
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Ellipse
from IPython.display import display, clear_output

# Oppretter en figur og akse med en størrelse på 20x10 tommer
fig, ax = plt.subplots(figsize=(20, 10))

# Setter begrensninger for y- og x-aksen
ax.set_ylim([0,250])            # Y-aksen går fra 0 til 250
ax.set_xlim([0,20])             # X-aksen går fra 0 til 20

# Initierer med en rekke verdier (x = 0, y = 100, dy = 0)
x, y, dy = 0 ,100 ,0

# Lager tomme lister som vil lagre x- og y-posisjoner gjennom løkka
ypath = []
xpath = []

# While-løkka kjører så lenge x < 25, og for hvert steg økes x med 0.1
while x < 25:
    x += 0.1            # Øker x med 0.1 for hvert steg
    y += dy             # Legger til dy til y-posisjonen (endrer y basert på dy)
    
    # Oppdaterer dy med en ny tilfeldig verdi som varierer mellom -20 og 20.
    # np.random.rand() gir en tilfeldig verdi mellom 0 og 1, 
    # så 40 * (np.random.rand() - 0.5) gir et tilfeldig tall mellom -20 og 20.
    # Dette gir y-posisjonen en tilfeldig variasjon ved hvert steg.
    dy = 40 * (np.random.rand() - 0.5)

    # Legger til de nye x- og y-verdiene i listene xpath og ypath
    xpath.append(x)
    ypath.append(y)

# Plotter banen for y-verdiene som funksjon av x, med etiketten 'YARA'
ax.plot(xpath, ypath, label='YARA')

# Legger til en legende (forklaring) øverst til venstre på plottet
ax.legend(loc='upper left', frameon=False, fontsize=30)

# Viser plottet
plt.show()
```

## Simulering av stokastisk bevegelse - forklaring av koden fra eksempel 6 

Denne koden simulerer en tilfeldig bevegelse over tid, som kan brukes til å modellere aksjekurser eller andre økonomiske prosesser med usikkerhet.  

### 🔹 Hvordan fungerer simuleringen?  
- Vi starter med en initial verdi **y = 100** og en tilfeldig endring **dy**.
- Hver iterasjon øker **x** med **0.1**, og **y** justeres med en tilfeldig verdi.
- **dy** oppdateres tilfeldig mellom **-20 og 20**, slik at vi får en tilfeldig variasjon i y-posisjonen.
- Bevegelsen plottes som en kurve, og resultatet viser hvordan verdien utvikler seg over tid.

### 🔹 Forklaring av kode:
- **`ax.set_ylim([0,250])`** og **`ax.set_xlim([0,20])`** setter grensene for x- og y-aksen.
- **`while x < 25:`** sørger for at simuleringen kjører til x når 25.
- **`dy = 40 * (np.random.rand() - 0.5)`** genererer en tilfeldig endring mellom -20 og 20.
- **`ax.plot(xpath, ypath, label='YARA')`** tegner banen for den simulerte bevegelsen.

Kjør koden flere ganger for å se hvordan den tilfeldige bevegelsen varierer!

# Dynamisk plott 📉

Om vi ønsker å formidle kunnskap, er det av og til nyttig med dynamiske plott. Altså plott som endrer seg mens du ser på dem. Vi kan gjøre det ved å rykke inn de to siste setningene fra Eksempel 6. 

Det er disse setningene som lager plottet. Ved å rykke dem inn, plottes figuren i hver iterasjon. 

### 🔹 Viktig å merke seg:
- Uten **`clear_output(wait=True)`**, ville vi sett **25 separate figurer** i stedet for én dynamisk oppdatering. 
- I tillegg, så legger vi til at y-verdien ikke kan bli mindre enn $0$. Det gjør vi her **`while x < 25 and y >=0`**.

Kjør koden i Eksempel 7 og se hvordan den simulerte bevegelsen utvikler seg i sanntid! 

#### Eksempel 7:

```{python}
x, y, dy = 0, 100, 0

ypath = []
xpath = []

while x < 25 and y >=0:
    x += 0.1
    y += dy
    dy = 40 * (np.random.rand() - 0.5)

    xpath.append(x)
    ypath.append(y)
    
    # Ved å plassere plot-funksjonen inne i løkka, sørger vi for at den plottes ved hver iterasjon
    ax.plot(xpath, ypath, label='YARA')
    ax.legend(loc='upper left', frameon=False, fontsize=30)
    
    # Jupyter viser som standard bare siste utsagn, så vi må legge til dette
    # for å plotte på hver iterasjon
    display(fig)
    
    # Sørger for at plottet og utdataene blir slettet hver gang:
    ax.cla()
    ax.set_ylim([0, 400])
    ax.set_xlim([0, 20])
    clear_output(wait=True)
```

# Legge til litt effekter 🔄

Det er også gøy med litt effekter når vi skal formidle noe, bare det ikke blir så mye at det drar oppmerksomheten bort fra det vi skal formidle. I denne simuleringen er det veldig fristende å lage en lite rød prikk som "leder" aksjekursen videre. Vi skal også legge til en liten tekst som forteller hva aksjekursen er:

#### Eksempel 8:

```{python}
x, y, dy= 0, 100, 0

ypath=[]
xpath=[]

while x<25 and y >= 0:
    x+= 0.1
    y+= dy
    dy=40*(np.random.rand()-0.5)


    xpath.append(x)
    ypath.append(y)
    
    # Placing the plot function inside the loop, ensures that it is plotted every iteration
    ax.plot(xpath,ypath,label='YARA')
    ax.legend(loc='upper left',frameon=False,fontsize=30)
    
    # Making dot:
    c=Ellipse((x, y), 0.25,5, color='r')
    ax.add_patch(c)
    
    # Making text:
    ax.text(x+0.1,y+3,f'NOK {np.round(y,1)}')
    
    # Jupyter only shows the last statement by default, so we need to add this 
    # in order to plot at every iteration
    display(fig)
    
    # Makes sure the plot and output are ereased each time:
    ax.cla()
    ax.set_ylim([0,800])
    ax.set_xlim([0,25])
    clear_output(wait = True)
```

#### **Selv om det går an å bruke jupyter og matplotlib til å lage visuelle effekter, går det litt tregt om du skal lage noer mer avansert. Den mest vanlige pakken for å lage grafisk brukergrensesnitt i Python heter ´tkinter´. Vi går imidlertid ikke inn på denne pakken i dette kurset.**

## Men for den interesserte - under her er et eksempel på kode som benytter seg av `tkinter` for dynamisk plotting.

```{python}
# Importerer nødvendige bibliotek
import tkinter as tk
from tkinter import ttk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
from matplotlib.patches import Ellipse

# Initialiserer variablene
x, y, dy = 0, 100, 0
xpath, ypath = [], []

# Funksjon for å oppdatere verdiene - og plotte underveis.
def update_plot():
    global x, y, dy, xpath, ypath

    x += 0.5
    y += dy
    dy = 40 * (np.random.rand() - 0.5)

    xpath.append(x)
    ypath.append(y)

    # "Vasker" eller "Cleare'r" det forrige plottet
    ax.clear()
    ax.set_ylim([0, 200])
    ax.set_xlim([0, 20])

    # Plot den oppdaterte 'path'en.
    ax.plot(xpath, ypath, label='YARA')
    ax.legend(loc='upper left', frameon=False, fontsize=10)

    # Legg til 'sist' punkt som en ellipse
    c = Ellipse((x, y), 0.25, 5, color='r')
    ax.add_patch(c)

    # Legg til tekst som viser den siste y-verdien
    ax.text(x + 0.1, y + 3, f'NOK {np.round(y, 1)}')

    # Tegn det oppdaterte plottet
    canvas.draw()

    # Fortsett å oppdater hvert 500 millisekund (0,5 sek)
    if x < 20:
        root.after(500, update_plot)

# Lager "hovedvinduet" (the main window)
root = tk.Tk()
root.title('Dynamic Economic Visualization')

# Lager en ramme (frame) for matplotlib plottet
frame = ttk.Frame(root)
frame.pack(fill=tk.BOTH, expand=1)

# Lager en matplotlib figur
fig = Figure(figsize=(8, 6))
ax = fig.add_subplot(111)
ax.set_ylim([0, 200])
ax.set_xlim([0, 20])

# Create a canvas to display the figure
canvas = FigureCanvasTkAgg(fig, master=frame)
canvas.get_tk_widget().pack(fill=tk.BOTH, expand=1)

# Start oppdateringsprosessen
root.after(500, update_plot)

# Starter Tkinter loop'en
root.mainloop()
```

# 🔢 Numerisk optimering  

Tidligere har vi funnet maksverdien av funksjoner ved å bruke **Sympy** til å derivere en funksjon, sette den lik null og løse for $x$.  

Men hva om det er vanskelig å finne den optimale løsningen analytisk? (Noe det ofte kan være!) 

I slike tilfeller kan vi bruke **numerisk optimering**, der vi evaluerer objektfunksjonen (det vi ønsker å maksimere) for mange ulike verdier og velger den beste.  

### Hva gjør vi i dette eksemplet?  
Vi ser på en bedrift som selger $Q$ enheter av en vare til pris $p$, med en kostnad per enhet $C$.  
Bedriftens **fortjeneste** (profit) er gitt ved:  

$p \cdot Q - C \cdot Q$

Vi bruker numeriske metoder for å finne verdien av $Q$ som maksimerer fortjenesten.  

Videre, antar vi at etterspørselfunksjonen (som bestemmer $Q$) er definert slik:

$100 - p$

Selv om vi i dette tilfellet enkelt kan finne maksimum analytisk med **Sympy**, kan vi bruke dette eksempelet for å sjekke at den numeriske løsningen er korrekt.  

Numerisk optimering er nyttig når:
- Funksjonen er **komplisert** og vanskelig å derivere.
- Vi har **diskrete verdier** der derivasjon ikke er praktisk.
- Vi ønsker å **visualisere hvordan løsningen varierer** over et bredt spekter av verdier.

La oss nå implementere dette i Python i eksemplene under!

### Eksempel 11:

```{python}
# Definerer fortjenestefunksjonen, som avhenger av en etterspørsel.
def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q
```

Q bestemmes av en etterspørselfunksjon.

#### Eksempel 12

```{python}
# Definerer etterspørselfunksjonen
def demand(p):
    """Returnerer antall enheter solgt gitt en pris p."""
    return 100 - p
```

Vi kan nå finne optimum numerisk, altså tallverdiene (optimal pris og hva maksimal profitt er ved denne optimale prisen.)

#### Eksempel 13:

```{python}
import numpy as np

def find_optimal_price(start, end, C):
    """Finner optimal pris i prisintervallet (start, end)"""
    max_profit = float('-inf')
    optimal_price = None
    n_samples = 1000
    
    # Itererer over pris-intervallet (start, end)
    for p in np.linspace(start, end, n_samples):
        current_profit = profit(p, C)
        if current_profit > max_profit:
            # Hvis 'profit' går over 'current profit', så lagrer vi den nye 'profit' og pris
            max_profit = current_profit
            optimal_price = p

    return optimal_price, max_profit


cost = 5
start_price = 0
end_price = 100

optimal_price, max_profit = find_optimal_price(start_price, end_price, cost)

print(f"Optimal pris: {optimal_price}")
print(f"Maksimal profitt ved optimal pris: {max_profit}")
```

```{python}
### Vi visualiserer profit funksjonen over - for å se om resultatet virker rimelig ###
import matplotlib.pyplot as plt
import numpy as np


# Kostnad per enhet ost, start_price og end_price (du kan justere denne verdien)
cost = 5
start_price = 0
end_price = 100

# Lag en array med p-verdier fra 0 til 100
p_values = np.linspace(start_price, end_price, 500)

# Beregn profitt for hver p-verdi
profit_values = [profit(p, cost) for p in p_values]

# Plotter profittfunksjonen
plt.plot(p_values, profit_values, label="Profitt")
plt.title("Profitt som funksjon av pris", fontsize=14)
plt.xlabel("Pris (p)", fontsize=12)
plt.ylabel("Profitt", fontsize=12)
plt.ylim(0, 2500)  # Setter y-aksen fra 0 til 3000
plt.xlim(0, 100)   # Setter x-aksen fra 0 til 150
plt.axvline(x=optimal_price, color='red', linestyle='--', label=f'p = {round(optimal_price)}')
plt.legend()
plt.show()
```

Det ser ut som at optimal prisen på drøye $52$ passer godt til å være optimalpris!

Vi kan verifisere dette enda en gang, ved hjelp av ```SymPy```.

#### Eksempel 14:

```{python}
import sympy as sp

# Definerer variabelen p (pris)
p = sp.Symbol('p')

# Kostnad C er satt til 30
C = 5

# Etterspørselsfunksjon
def demand(p):
    return 100 - p

def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q

# Deriverer profittfunksjonen med hensyn til p
profit_derivative = sp.diff(profit(p, C), p)

# Finn den optimale p-verdien ved å løse ligningen profit_derivative = 0
optimal_p = sp.solve(profit_derivative, p)

# Viser den optimale prisen
optimal_p_value = round(optimal_p[0], 2)
optimal_p_value
```

# Monte Carlo-simulering 🖥️ 🎲 📊

Monte Carlo-simulering er en metode for å estimere resultater ved hjelp av tilfeldige prøver.  
Denne teknikken er spesielt nyttig når det er **usikkerhet** i dataene eller **mange mulige utfall**.  

### 🔹 Hvorfor bruke Monte Carlo-simulering?  
- Mange økonomiske prosesser, som **investeringer og lønnsvekst**, er usikre.  
- Deterministiske modeller fanger **ikke opp tilfeldigheter**, noe Monte Carlo-simulering gjør.  
- Vi kan bruke denne teknikken for å lage **sannsynlighetsfordelinger** og forutsi mulige utfall.  

I dette eksempelet ser vi på **inntektsutvikling** over tid, hvor inntekten hvert år avhenger av fjoråret.  
- **Vi starter med en gitt inntekt** og antar en årlig vekstrate (én prosent).  
- **Hvert år legges en tilfeldig variasjon til**, som representerer usikkerhet.  
- Vi kjører simuleringen mange ganger for å se hvordan inntekten utvikler seg over tid.  

Vi starter med å definere en funksjon som beregner neste års inntekt, basert på fjoråret og et tilfeldig bidrag: 

#### Eksempel 15

```{python}
import numpy as np

def calc_income(last_year_income, growth_rate, volatility):
    
    random_growth = np.random.normal(0, volatility)
    growth =  growth_rate + random_growth
    
    income = round(last_year_income * (1 + growth))
    
    return income

# Her antar vi at fjorårets lønn er 600.000kr, med 5% forventet inntektsøkning og 2% usikkerhet

print(f'Hvis fjorårets lønn er 600.000 kr, så er årets lønn {calc_income(600000, 0.05, 0.02)}, hvis vi har 5% forventet lønnsøkning og 2% usikkerhet.')
```

#### **Så lager vi en funksjon som lager en "inntektssti" (income path) for et gitt antall års inntekt. Dette kalles en "sti"/"path" fordi dagens inntekt er avhengig av gårsdagen. Dagens situasjon er altså avhengig av hvilken sti inntekten har fulgt i alle tidligere år.**

#### Eksempel 16

```{python}
def income_path(years, initial_income, growth_rate, volatility):
    
    incomes = [initial_income]
    
    #simulating a single income path:
    for year in range(years-1):

        #calculating income:
        income = calc_income(incomes[-1], growth_rate, volatility)

        #adding income for year to the path
        incomes.append(income)
        
    return incomes

#regner ut for fem år:

income_path(5,600000, 0.05, 0.02)
```

#### **Vi kan nå lage en funksjon som simulerer et gitt antall inntektsstier gitt ved `num_simulations`:**

#### Eksempel 17:

```{python}
import pandas as pd

def simulate_income(years, initial_income, growth_rate, volatility, num_simulations):
    """Returnerer en 2D-array med simulerte inntekter for hvert år."""
    # Starter med en tom liste, hvor vi skal fylle på med tall
    all_incomes = []
    for _ in range(num_simulations):
        # Legger til "the path" til variabelesn 'all_incomes'
        incomes = income_path(years, initial_income, growth_rate, volatility)
        all_incomes.append(incomes)
    plt.figure(figsize=(10, 5))
        
    return np.array(all_incomes)

# Setter inn i pandas DataFrame for å få en visuelt, finere tabell

pd.DataFrame(simulate_income(5, 600000, 0.05, 0.02, 5))
```

#### **Vi kan nå plotte fordelingen, for å få et inntrykk av fordelingen til inntekten i avslutningsåret:**

#### Eksempel 18:

```{python}
import matplotlib.pyplot as plt

# Parametere
initial_income = 600000   # Start-inntekt
growth_rate = 0.03        # Forventet lønnsvekst (prosent)
volatility = 0.02         # Volatilitet (usikkerhet)
years = 30                # Antall år
num_simulations = 1000    # Antall simuleringer

simulated_incomes = simulate_income(years, initial_income, growth_rate, volatility, num_simulations)

# plotting the final income
final_year_incomes = simulated_incomes[:, -1]

plt.hist(final_year_incomes, bins=50, edgecolor='black', alpha=0.75)
plt.gca().get_xaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
plt.xticks(rotation=90)
plt.title("Distribusjon av simulerte inntekter etter 30 år")
plt.xlabel("Inntekt")
plt.ylabel("Antall simuleringer")
plt.show()
```

### **Ekstra visualisering: Plotte flere inntektsstier**
Eksempel 18 (rett over), viser distribusjon (fordelingen) av simulerte inntekter etter $30$ år - hvor startinntekten var på $600 \; 000$ kr.

For å vise hvordan ulike simuleringer utvikler seg over tid, kan vi legge til en graf som viser hvordan inntektsbanene utviklet seg.

Eksempel 19:

```{python}
plt.figure(figsize=(10, 5))

for i in range(1000):  # Plotter de 1000 inntektsstiene fra over
    plt.plot(simulated_incomes[i], alpha=0.5)

plt.title("Simulerte inntektsbaner over tid")
plt.xlabel("År")
plt.ylabel("Inntekt (MNOK)")
plt.show()
```

## **Ekstra-Ekstra IKKE PENSUM, MEN KJEKT Å VITE OM**
Vi kan lage flotte plots, ved hjelp av noe som heter Plotly. Se kodeblokken under, for eksempel:

```{python}
import plotly.graph_objects as go

# Assuming simulated_incomes is already defined

fig = go.Figure()

# Lager en loop som går igjennom de 10 første simulerte inntekts-path'ene
for i in range(10):
    fig.add_trace(go.Scatter(
        x=list(range(2005, 2023)),  # Årstall fra 2005 til 2022
        y=simulated_incomes[i],
        mode='lines',
        line=dict(width=2),  # Customize line width if needed
        opacity=0.5,  # Set the opacity for the lines
        name=f"Inntektssti nr. {i+1}" if i == 0 else None  # Only label the first line
    ))

# Oppdater layout
fig.update_layout(
    title="Simulerte inntektsbaner over tid",
    xaxis_title="År",
    yaxis_title="Inntekt (MNOK)",
    showlegend=False
)

# Vis figuren
fig.show()
```

# Oppgaver

### Oppgave 1 - 📈 Simulering av aksjekurs  
En aksjekurs beveger seg tilfeldig over tid. Vi antar at aksjen starter på **100 kroner** og endrer seg tilfeldig for hver tidsperiode.  

- **Lag en simulering av aksjekursen over 100 dager**  
- Hver dag endrer aksjekursen seg med en tilfeldig verdi mellom -3% og +3%  
- Plott kursutviklingen  

*Tips: Bruk en for-løkke og lagre verdiene i en liste! * 

Koden kan gjerne starte noe ala dette:

```python
# Parametere
days = 100
price = 100
prices = [price]

# Fortsett koden under - simulering og plotting
```


### Oppgave 2 - 🏢 Simulering av bedriftens overskudd 
En bedrift selger **Q** produkter til pris **p**, og produksjonskostnaden per enhet er **C**.  
Overskuddet beregnes som:  

$\text{Overskudd} = Q \cdot p - Q \cdot C$

**Lag en simulering der**:  
- **Q** varierer mellom 900 og 1100  
- **p** varierer mellom 90 og 110  
- **C** varierer mellom 50 og 70  

* Kjør simuleringen **1000 ganger**  
* Plott histogram av overskuddet  

*Tips: Bruk numpy for å generere tilfeldige verdier!*  


### Oppgave 3 - 💰 Simulering av lånekostnader  
Du tar opp et boliglån på **2 000 000 kr**. Renten er i utgangspunktet **3%**, men den varierer tilfeldig mellom **2% og 5%** hvert år.  

- **Simuler utviklingen i lånekostnader over 30 år**  
- Beregn den totale rentekostnaden etter 30 år  
- Kjør simuleringen **500 ganger**, og plott fordelingen av totale rentekostnader


### Oppgave 4 - 📦 Simulering av lagerstyring og etterspørsel  
Et selskap håndterer en vare med en ukentlig etterspørsel som varierer mellom **80 og 120 enheter**.  
De bestiller varer hver uke basert på en prognose, men **det er alltid en usikkerhet på ±10% i etterspørselen**.  

- **Simuler lagerbeholdning over 52 uker**  
- Start med et lager på **500 enheter**  
- Hvis lageret går under **100 enheter**, bestilles **200 nye enheter**  
- Plott utviklingen i lagerbeholdning over tid


# Oppgave 5 - Simuleringer 💰🎲💰
Du er på tur med vennegjengen din på casino i Monaco, og spiller et (fiktivt) terningspill. 

Du vet at en vanlig terning følger en $\textit{diskret uniform fordeling}$, hvor det er like stor sannsynlighet for hvert $\textit{utfall}$ (altså om terningen viser $1, \; 2, \; 3, \; 4, \; 5$ eller $6$).

I statistikk, snakker vi ofte om $\textit{forventningsverdi}$ (skrives $E[X]$), som sier noe om hva vi forventer en tilfeldig variabel $X$ vil være. For diskret problemer er det definert som 
$$E[X] = \sum_{i=1}^{n}x_i \cdot P(X=x_i)$$

hvor $x_i$ er verdien av terningen, og $P(X=x_i)$ er sannsynligheten for å få verdien $x_i$ på et kast. Vi vet at $n=6$, ettersom det er $6$ ulike utfall av en terning. Da kan vi skrive det ut slik:
$$E[X] = 1 \cdot \frac{1}{6} + 2 \cdot \frac{1}{6} + \cdots + 6 \cdot \frac{1}{6}$$
regner vi ut dette ser vi at vi får
$$E[X] =3,5$$ 

Dermed er forventningsverdien til en terning lik $3,5$.

## Case
I dette fiktive terningsspillet i Monaco skal man trille to terninger, samtidig. Man vinner spillet hvis summen av de to terningene er *over eller lik* $9$. 
Du kommer på at du kan simulere utfall ved hjelp av Python og Numpy.

## Oppgave 5.1
Bruk simulering, til å finne ut sannsynligheten for at du triller to treninger med sum $\textbf{over eller lik}$ $9$. 
- Visualiser utfallene ved bruk av et histogram.
- Antall simuleringer skal dere velge selv, men kommenter hvorfor dere velger som dere gjør.
- Under er et lite kodehint for hva dere kan ta i bruk.
```python
        # Mulige bibliotek for oppgaven.
        import numpy as np
        import matplotlib.pyplot as plt
        import random

        # Du kan få bruk for funksjonen (hvor argumentene må spesifiseres i henhold til oppgaven). Hvor low = inkludert, high = ekskludert.
        np.random.randint(low, high=None, size=None, dtype=int)
```

## Oppgave 5.2
Finn ut hvor mange kast av to terninger må du ta ($n$) for at sannsynligheten for å få en sum over eller lik $9$ minst én gang er over $90$%. 

Hint - formelen for å finne sannsynligheten for at summen er over eller lik 9, minst én gang er gitt som følgende:
$$P(\text{summen} \geq 9 \text{ minst én gang}) = 1 - \left(P(\text{summen} < 9)\right)^n$$

hvor $P\left(\text{summen} < 9\right)$ kan finnes fra simuleringen over.

Bruk ```sympy``` for å løse dette problemet, og si hvor mange ganger ($n$) vi må trille terningen.


