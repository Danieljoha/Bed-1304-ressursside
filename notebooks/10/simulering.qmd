---
title: 9 - Simulering
jupyter: python3
---



L√∏kker er noe av det mest brukte verkt√∏yet for en programmerer. En l√∏kke er en programkode som repeteres, og det har vi g√•tt igjennom tidligere i kurset. 

Det finnes i hovedsak to typer l√∏kker i Python: `while`-l√∏kker og `for`-l√∏kker. En `while` lar l√∏kken l√∏pe til en betingelse er oppfylt, mens `for` l√∏kken repeterer koden for alle elementene i en liste eller annen *iterativ datastruktur*. 

# For-l√∏kker

Her er eksempel p√• en `for`-l√∏kke som deriverer alle utrykkene i listen `expressions`:

#### Eksempel 1:
Vi har tidligere i kurset sett p√• ```sympy``` og derivasjon - dette kan vi ogs√• gj√∏re ved hjelp av en ```for```-l√∏kke, for √• iterere gjennom en liste. 

```{python}
from IPython.display import Markdown, display
import sympy as sp

x,y=sp.symbols("x y")

expressions=[
    sp.root(x,y),
    x**2+5*sp.exp(x),
    x*sp.ln(x)
]

for i in expressions:
    display(Markdown(f"Den deriverte av ${sp.latex(i)}$ er ${sp.latex(sp.diff(i,x))}$"))
```

#### Eksempel 2:
Eller du kan bare gj√∏re en enkel iterasjon for heltall fra en startverdi til en sluttverdi:

```{python}
for i in range(5,8):
    print(i)
    
for i in range(3):
    print(i)
```

Du kan ogs√• "pakke ut" elementer, dersom hvert element i `for`-setningen har et bestemt antall sub-elementer. La oss f√∏rst lage en liste som inneholder en ¬¥tuple¬¥ med uttrykkene i `expressions` over, og den deriverte av disse:

#### Eksempel 3:

```{python}
#using list comprehension to generate a list with expression,derivative tuples:
expressions_w_derivatives=[ (i, sp.diff(i,x)) for i in expressions ]
expressions_w_derivatives
```

Vi kan n√• kj√∏re en for-l√∏kke som forventer at hvert element i listen er en *iterabel* (for eksempel liste eller tuple) med to elementer:

#### Eksempel 4

```{python}
for function,derivative in expressions_w_derivatives:
    display(Markdown(f"Den deriverte av ${sp.latex(function)}$ er ${sp.latex(derivative)}$"))
```

# While-l√∏kker

En `while`-l√∏kke er en l√∏kke som fortsetter inntil en betingelse er oppfylt. I eksemplet under ser vi at det genereres nye tilfeldige aksjekurser s√• lenge kursen er under 125 kroner . 

Aksjen skal bevege seg tilfeldig. For √• f√• til det bruker vi funksjonen `rand` fra `random`-modulen i numpy.  `np.random.rand()` gir et tilfeldig tall mellom null og √©n, s√• ved √• multiplisere `(np.random.rand()-0.5)` med 40, f√•r vi et tilfeldig tall mellom -20 og 20. 

#### Eksempel 5:

```{python}
import numpy as np

dy, y = 0, 100

while y < 125:  
    y += dy
    dy = 40*(np.random.rand()-0.5) 
    #print(y)
```

Legg spesielt merke til `y+=dy` over. Denne operasjonen legger `dy` til `y`, og tilsvarer alts√• `y=y+dy`. De aller fleste programmeringsspr√•k st√∏tter `+=`-operatoren.  

Legg ogs√• merke til at vi kan sette flere variabler samtidig, ved √• skille b√•de variablene og verdiene med like mange kommaer, `dy,y=0,100`

# Dette leder oss inn p√• denne notatboken sitt tema - **Simuleringer** üìä üìà üìâ

Simuleringer brukes i √∏konomi for √• modellere usikkerhet, teste hypoteser og analysere sannsynlige utfall.  
I denne notatboken skal vi utforske hvordan vi kan bruke Python til √• simulere √∏konomiske problemstillinger ved hjelp av tilfeldige tall og statistiske teknikker.

Vi vil se p√•:
- Generering av tilfeldige tall
- Monte Carlo-simuleringer
- Simulering av √∏konomiske prosesser, som prisutvikling og risikoanalyse

L√∏kker kan brukes til mye, s√• la oss se p√• et eksempel p√• simulering. 

Simulering vil si √• trekke tilfeldige tall for √• se hvordan en modell opptrer under usikkerhet. 
## Simulering av aksjekurs üíπ

I denne simuleringen antar vi at en aksjekurs starter p√• 100 kr og beveger seg tilfeldig over tid.  
Vi observerer aksjen hvert sjette minutt, eller √©n tidel (0.1) av en time. Tiden √∏ker dermed med 0.1 i hver periode. 

For √• tegne opp stien til aksjekursen, lager vi f√∏rst lister for x- og y-verdiene, og s√• legger vi til elementer i hver av listene med `append`-funksjonen til listeobjektene, f√∏r listen plottes som en graf. Kj√∏r koden flere ganger, for √• se ulike simuleringer. 

#### Eksempel 6:

```{python}
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Ellipse
from IPython.display import display, clear_output

# Oppretter en figur og akse med en st√∏rrelse p√• 20x10 tommer
fig, ax = plt.subplots(figsize=(20, 10))

# Setter begrensninger for y- og x-aksen
ax.set_ylim([0,250])            # Y-aksen g√•r fra 0 til 250
ax.set_xlim([0,20])             # X-aksen g√•r fra 0 til 20

# Initierer med en rekke verdier (x = 0, y = 100, dy = 0)
x, y, dy = 0 ,100 ,0

# Lager tomme lister som vil lagre x- og y-posisjoner gjennom l√∏kka
ypath = []
xpath = []

# While-l√∏kka kj√∏rer s√• lenge x < 25, og for hvert steg √∏kes x med 0.1
while x < 25:
    x += 0.1            # √òker x med 0.1 for hvert steg
    y += dy             # Legger til dy til y-posisjonen (endrer y basert p√• dy)
    
    # Oppdaterer dy med en ny tilfeldig verdi som varierer mellom -20 og 20.
    # np.random.rand() gir en tilfeldig verdi mellom 0 og 1, 
    # s√• 40 * (np.random.rand() - 0.5) gir et tilfeldig tall mellom -20 og 20.
    # Dette gir y-posisjonen en tilfeldig variasjon ved hvert steg.
    dy = 40 * (np.random.rand() - 0.5)

    # Legger til de nye x- og y-verdiene i listene xpath og ypath
    xpath.append(x)
    ypath.append(y)

# Plotter banen for y-verdiene som funksjon av x, med etiketten 'YARA'
ax.plot(xpath, ypath, label='YARA')

# Legger til en legende (forklaring) √∏verst til venstre p√• plottet
ax.legend(loc='upper left', frameon=False, fontsize=30)

# Viser plottet
plt.show()
```

## Simulering av stokastisk bevegelse - forklaring av koden fra eksempel 6 

Denne koden simulerer en tilfeldig bevegelse over tid, som kan brukes til √• modellere aksjekurser eller andre √∏konomiske prosesser med usikkerhet.  

### üîπ Hvordan fungerer simuleringen?  
- Vi starter med en initial verdi **y = 100** og en tilfeldig endring **dy**.
- Hver iterasjon √∏ker **x** med **0.1**, og **y** justeres med en tilfeldig verdi.
- **dy** oppdateres tilfeldig mellom **-20 og 20**, slik at vi f√•r en tilfeldig variasjon i y-posisjonen.
- Bevegelsen plottes som en kurve, og resultatet viser hvordan verdien utvikler seg over tid.

### üîπ Forklaring av kode:
- **`ax.set_ylim([0,250])`** og **`ax.set_xlim([0,20])`** setter grensene for x- og y-aksen.
- **`while x < 25:`** s√∏rger for at simuleringen kj√∏rer til x n√•r 25.
- **`dy = 40 * (np.random.rand() - 0.5)`** genererer en tilfeldig endring mellom -20 og 20.
- **`ax.plot(xpath, ypath, label='YARA')`** tegner banen for den simulerte bevegelsen.

Kj√∏r koden flere ganger for √• se hvordan den tilfeldige bevegelsen varierer!

# Dynamisk plott üìâ

Om vi √∏nsker √• formidle kunnskap, er det av og til nyttig med dynamiske plott. Alts√• plott som endrer seg mens du ser p√• dem. Vi kan gj√∏re det ved √• rykke inn de to siste setningene fra Eksempel 6. 

Det er disse setningene som lager plottet. Ved √• rykke dem inn, plottes figuren i hver iterasjon. 

### üîπ Viktig √• merke seg:
- Uten **`clear_output(wait=True)`**, ville vi sett **25 separate figurer** i stedet for √©n dynamisk oppdatering. 
- I tillegg, s√• legger vi til at y-verdien ikke kan bli mindre enn $0$. Det gj√∏r vi her **`while x < 25 and y >=0`**.

Kj√∏r koden i Eksempel 7 og se hvordan den simulerte bevegelsen utvikler seg i sanntid! 

#### Eksempel 7:

```{python}
x, y, dy = 0, 100, 0

ypath = []
xpath = []

while x < 25 and y >=0:
    x += 0.1
    y += dy
    dy = 40 * (np.random.rand() - 0.5)

    xpath.append(x)
    ypath.append(y)
    
    # Ved √• plassere plot-funksjonen inne i l√∏kka, s√∏rger vi for at den plottes ved hver iterasjon
    ax.plot(xpath, ypath, label='YARA')
    ax.legend(loc='upper left', frameon=False, fontsize=30)
    
    # Jupyter viser som standard bare siste utsagn, s√• vi m√• legge til dette
    # for √• plotte p√• hver iterasjon
    display(fig)
    
    # S√∏rger for at plottet og utdataene blir slettet hver gang:
    ax.cla()
    ax.set_ylim([0, 400])
    ax.set_xlim([0, 20])
    clear_output(wait=True)
```

# Legge til litt effekter üîÑ

Det er ogs√• g√∏y med litt effekter n√•r vi skal formidle noe, bare det ikke blir s√• mye at det drar oppmerksomheten bort fra det vi skal formidle. I denne simuleringen er det veldig fristende √• lage en lite r√∏d prikk som "leder" aksjekursen videre. Vi skal ogs√• legge til en liten tekst som forteller hva aksjekursen er:

#### Eksempel 8:

```{python}
x, y, dy= 0, 100, 0

ypath=[]
xpath=[]

while x<25 and y >= 0:
    x+= 0.1
    y+= dy
    dy=40*(np.random.rand()-0.5)


    xpath.append(x)
    ypath.append(y)
    
    # Placing the plot function inside the loop, ensures that it is plotted every iteration
    ax.plot(xpath,ypath,label='YARA')
    ax.legend(loc='upper left',frameon=False,fontsize=30)
    
    # Making dot:
    c=Ellipse((x, y), 0.25,5, color='r')
    ax.add_patch(c)
    
    # Making text:
    ax.text(x+0.1,y+3,f'NOK {np.round(y,1)}')
    
    # Jupyter only shows the last statement by default, so we need to add this 
    # in order to plot at every iteration
    display(fig)
    
    # Makes sure the plot and output are ereased each time:
    ax.cla()
    ax.set_ylim([0,800])
    ax.set_xlim([0,25])
    clear_output(wait = True)
```

#### **Selv om det g√•r an √• bruke jupyter og matplotlib til √• lage visuelle effekter, g√•r det litt tregt om du skal lage noer mer avansert. Den mest vanlige pakken for √• lage grafisk brukergrensesnitt i Python heter ¬¥tkinter¬¥. Vi g√•r imidlertid ikke inn p√• denne pakken i dette kurset.**

## Men for den interesserte - under her er et eksempel p√• kode som benytter seg av `tkinter` for dynamisk plotting.

```{python}
# Importerer n√∏dvendige bibliotek
import tkinter as tk
from tkinter import ttk
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
from matplotlib.patches import Ellipse

# Initialiserer variablene
x, y, dy = 0, 100, 0
xpath, ypath = [], []

# Funksjon for √• oppdatere verdiene - og plotte underveis.
def update_plot():
    global x, y, dy, xpath, ypath

    x += 0.5
    y += dy
    dy = 40 * (np.random.rand() - 0.5)

    xpath.append(x)
    ypath.append(y)

    # "Vasker" eller "Cleare'r" det forrige plottet
    ax.clear()
    ax.set_ylim([0, 200])
    ax.set_xlim([0, 20])

    # Plot den oppdaterte 'path'en.
    ax.plot(xpath, ypath, label='YARA')
    ax.legend(loc='upper left', frameon=False, fontsize=10)

    # Legg til 'sist' punkt som en ellipse
    c = Ellipse((x, y), 0.25, 5, color='r')
    ax.add_patch(c)

    # Legg til tekst som viser den siste y-verdien
    ax.text(x + 0.1, y + 3, f'NOK {np.round(y, 1)}')

    # Tegn det oppdaterte plottet
    canvas.draw()

    # Fortsett √• oppdater hvert 500 millisekund (0,5 sek)
    if x < 20:
        root.after(500, update_plot)

# Lager "hovedvinduet" (the main window)
root = tk.Tk()
root.title('Dynamic Economic Visualization')

# Lager en ramme (frame) for matplotlib plottet
frame = ttk.Frame(root)
frame.pack(fill=tk.BOTH, expand=1)

# Lager en matplotlib figur
fig = Figure(figsize=(8, 6))
ax = fig.add_subplot(111)
ax.set_ylim([0, 200])
ax.set_xlim([0, 20])

# Create a canvas to display the figure
canvas = FigureCanvasTkAgg(fig, master=frame)
canvas.get_tk_widget().pack(fill=tk.BOTH, expand=1)

# Start oppdateringsprosessen
root.after(500, update_plot)

# Starter Tkinter loop'en
root.mainloop()
```

# üî¢ Numerisk optimering  

Tidligere har vi funnet maksverdien av funksjoner ved √• bruke **Sympy** til √• derivere en funksjon, sette den lik null og l√∏se for $x$.  

Men hva om det er vanskelig √• finne den optimale l√∏sningen analytisk? (Noe det ofte kan v√¶re!) 

I slike tilfeller kan vi bruke **numerisk optimering**, der vi evaluerer objektfunksjonen (det vi √∏nsker √• maksimere) for mange ulike verdier og velger den beste.  

### Hva gj√∏r vi i dette eksemplet?  
Vi ser p√• en bedrift som selger $Q$ enheter av en vare til pris $p$, med en kostnad per enhet $C$.  
Bedriftens **fortjeneste** (profit) er gitt ved:  

$p \cdot Q - C \cdot Q$

Vi bruker numeriske metoder for √• finne verdien av $Q$ som maksimerer fortjenesten.  

Videre, antar vi at ettersp√∏rselfunksjonen (som bestemmer $Q$) er definert slik:

$100 - p$

Selv om vi i dette tilfellet enkelt kan finne maksimum analytisk med **Sympy**, kan vi bruke dette eksempelet for √• sjekke at den numeriske l√∏sningen er korrekt.  

Numerisk optimering er nyttig n√•r:
- Funksjonen er **komplisert** og vanskelig √• derivere.
- Vi har **diskrete verdier** der derivasjon ikke er praktisk.
- Vi √∏nsker √• **visualisere hvordan l√∏sningen varierer** over et bredt spekter av verdier.

La oss n√• implementere dette i Python i eksemplene under!

### Eksempel 11:

```{python}
# Definerer fortjenestefunksjonen, som avhenger av en ettersp√∏rsel.
def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q
```

Q bestemmes av en ettersp√∏rselfunksjon.

#### Eksempel 12

```{python}
# Definerer ettersp√∏rselfunksjonen
def demand(p):
    """Returnerer antall enheter solgt gitt en pris p."""
    return 100 - p
```

Vi kan n√• finne optimum numerisk, alts√• tallverdiene (optimal pris og hva maksimal profitt er ved denne optimale prisen.)

#### Eksempel 13:

```{python}
import numpy as np

def find_optimal_price(start, end, C):
    """Finner optimal pris i prisintervallet (start, end)"""
    max_profit = float('-inf')
    optimal_price = None
    n_samples = 1000
    
    # Itererer over pris-intervallet (start, end)
    for p in np.linspace(start, end, n_samples):
        current_profit = profit(p, C)
        if current_profit > max_profit:
            # Hvis 'profit' g√•r over 'current profit', s√• lagrer vi den nye 'profit' og pris
            max_profit = current_profit
            optimal_price = p

    return optimal_price, max_profit


cost = 5
start_price = 0
end_price = 100

optimal_price, max_profit = find_optimal_price(start_price, end_price, cost)

print(f"Optimal pris: {optimal_price}")
print(f"Maksimal profitt ved optimal pris: {max_profit}")
```

```{python}
### Vi visualiserer profit funksjonen over - for √• se om resultatet virker rimelig ###
import matplotlib.pyplot as plt
import numpy as np


# Kostnad per enhet ost, start_price og end_price (du kan justere denne verdien)
cost = 5
start_price = 0
end_price = 100

# Lag en array med p-verdier fra 0 til 100
p_values = np.linspace(start_price, end_price, 500)

# Beregn profitt for hver p-verdi
profit_values = [profit(p, cost) for p in p_values]

# Plotter profittfunksjonen
plt.plot(p_values, profit_values, label="Profitt")
plt.title("Profitt som funksjon av pris", fontsize=14)
plt.xlabel("Pris (p)", fontsize=12)
plt.ylabel("Profitt", fontsize=12)
plt.ylim(0, 2500)  # Setter y-aksen fra 0 til 3000
plt.xlim(0, 100)   # Setter x-aksen fra 0 til 150
plt.axvline(x=optimal_price, color='red', linestyle='--', label=f'p = {round(optimal_price)}')
plt.legend()
plt.show()
```

Det ser ut som at optimal prisen p√• dr√∏ye $52$ passer godt til √• v√¶re optimalpris!

Vi kan verifisere dette enda en gang, ved hjelp av ```SymPy```.

#### Eksempel 14:

```{python}
import sympy as sp

# Definerer variabelen p (pris)
p = sp.Symbol('p')

# Kostnad C er satt til 30
C = 5

# Ettersp√∏rselsfunksjon
def demand(p):
    return 100 - p

def profit(p, C):
    """Beregner profitt gitt pris p og kostnad per enhet C."""
    Q = demand(p)
    return p * Q - C * Q

# Deriverer profittfunksjonen med hensyn til p
profit_derivative = sp.diff(profit(p, C), p)

# Finn den optimale p-verdien ved √• l√∏se ligningen profit_derivative = 0
optimal_p = sp.solve(profit_derivative, p)

# Viser den optimale prisen
optimal_p_value = round(optimal_p[0], 2)
optimal_p_value
```

# Monte Carlo-simulering üñ•Ô∏è üé≤ üìä

Monte Carlo-simulering er en metode for √• estimere resultater ved hjelp av tilfeldige pr√∏ver.  
Denne teknikken er spesielt nyttig n√•r det er **usikkerhet** i dataene eller **mange mulige utfall**.  

### üîπ Hvorfor bruke Monte Carlo-simulering?  
- Mange √∏konomiske prosesser, som **investeringer og l√∏nnsvekst**, er usikre.  
- Deterministiske modeller fanger **ikke opp tilfeldigheter**, noe Monte Carlo-simulering gj√∏r.  
- Vi kan bruke denne teknikken for √• lage **sannsynlighetsfordelinger** og forutsi mulige utfall.  

I dette eksempelet ser vi p√• **inntektsutvikling** over tid, hvor inntekten hvert √•r avhenger av fjor√•ret.  
- **Vi starter med en gitt inntekt** og antar en √•rlig vekstrate (√©n prosent).  
- **Hvert √•r legges en tilfeldig variasjon til**, som representerer usikkerhet.  
- Vi kj√∏rer simuleringen mange ganger for √• se hvordan inntekten utvikler seg over tid.  

Vi starter med √• definere en funksjon som beregner neste √•rs inntekt, basert p√• fjor√•ret og et tilfeldig bidrag: 

#### Eksempel 15

```{python}
import numpy as np

def calc_income(last_year_income, growth_rate, volatility):
    
    random_growth = np.random.normal(0, volatility)
    growth =  growth_rate + random_growth
    
    income = round(last_year_income * (1 + growth))
    
    return income

# Her antar vi at fjor√•rets l√∏nn er 600.000kr, med 5% forventet inntekts√∏kning og 2% usikkerhet

print(f'Hvis fjor√•rets l√∏nn er 600.000 kr, s√• er √•rets l√∏nn {calc_income(600000, 0.05, 0.02)}, hvis vi har 5% forventet l√∏nns√∏kning og 2% usikkerhet.')
```

#### **S√• lager vi en funksjon som lager en "inntektssti" (income path) for et gitt antall √•rs inntekt. Dette kalles en "sti"/"path" fordi dagens inntekt er avhengig av g√•rsdagen. Dagens situasjon er alts√• avhengig av hvilken sti inntekten har fulgt i alle tidligere √•r.**

#### Eksempel 16

```{python}
def income_path(years, initial_income, growth_rate, volatility):
    
    incomes = [initial_income]
    
    #simulating a single income path:
    for year in range(years-1):

        #calculating income:
        income = calc_income(incomes[-1], growth_rate, volatility)

        #adding income for year to the path
        incomes.append(income)
        
    return incomes

#regner ut for fem √•r:

income_path(5,600000, 0.05, 0.02)
```

#### **Vi kan n√• lage en funksjon som simulerer et gitt antall inntektsstier gitt ved `num_simulations`:**

#### Eksempel 17:

```{python}
import pandas as pd

def simulate_income(years, initial_income, growth_rate, volatility, num_simulations):
    """Returnerer en 2D-array med simulerte inntekter for hvert √•r."""
    # Starter med en tom liste, hvor vi skal fylle p√• med tall
    all_incomes = []
    for _ in range(num_simulations):
        # Legger til "the path" til variabelesn 'all_incomes'
        incomes = income_path(years, initial_income, growth_rate, volatility)
        all_incomes.append(incomes)
    plt.figure(figsize=(10, 5))
        
    return np.array(all_incomes)

# Setter inn i pandas DataFrame for √• f√• en visuelt, finere tabell

pd.DataFrame(simulate_income(5, 600000, 0.05, 0.02, 5))
```

#### **Vi kan n√• plotte fordelingen, for √• f√• et inntrykk av fordelingen til inntekten i avslutnings√•ret:**

#### Eksempel 18:

```{python}
import matplotlib.pyplot as plt

# Parametere
initial_income = 600000   # Start-inntekt
growth_rate = 0.03        # Forventet l√∏nnsvekst (prosent)
volatility = 0.02         # Volatilitet (usikkerhet)
years = 30                # Antall √•r
num_simulations = 1000    # Antall simuleringer

simulated_incomes = simulate_income(years, initial_income, growth_rate, volatility, num_simulations)

# plotting the final income
final_year_incomes = simulated_incomes[:, -1]

plt.hist(final_year_incomes, bins=50, edgecolor='black', alpha=0.75)
plt.gca().get_xaxis().set_major_formatter(plt.FuncFormatter(lambda x, loc: "{:,}".format(int(x))))
plt.xticks(rotation=90)
plt.title("Distribusjon av simulerte inntekter etter 30 √•r")
plt.xlabel("Inntekt")
plt.ylabel("Antall simuleringer")
plt.show()
```

### **Ekstra visualisering: Plotte flere inntektsstier**
Eksempel 18 (rett over), viser distribusjon (fordelingen) av simulerte inntekter etter $30$ √•r - hvor startinntekten var p√• $600 \; 000$ kr.

For √• vise hvordan ulike simuleringer utvikler seg over tid, kan vi legge til en graf som viser hvordan inntektsbanene utviklet seg.

Eksempel 19:

```{python}
plt.figure(figsize=(10, 5))

for i in range(1000):  # Plotter de 1000 inntektsstiene fra over
    plt.plot(simulated_incomes[i], alpha=0.5)

plt.title("Simulerte inntektsbaner over tid")
plt.xlabel("√Ör")
plt.ylabel("Inntekt (MNOK)")
plt.show()
```

## **Ekstra-Ekstra IKKE PENSUM, MEN KJEKT √Ö VITE OM**
Vi kan lage flotte plots, ved hjelp av noe som heter Plotly. Se kodeblokken under, for eksempel:

```{python}
import plotly.graph_objects as go

# Assuming simulated_incomes is already defined

fig = go.Figure()

# Lager en loop som g√•r igjennom de 10 f√∏rste simulerte inntekts-path'ene
for i in range(10):
    fig.add_trace(go.Scatter(
        x=list(range(2005, 2023)),  # √Örstall fra 2005 til 2022
        y=simulated_incomes[i],
        mode='lines',
        line=dict(width=2),  # Customize line width if needed
        opacity=0.5,  # Set the opacity for the lines
        name=f"Inntektssti nr. {i+1}" if i == 0 else None  # Only label the first line
    ))

# Oppdater layout
fig.update_layout(
    title="Simulerte inntektsbaner over tid",
    xaxis_title="√Ör",
    yaxis_title="Inntekt (MNOK)",
    showlegend=False
)

# Vis figuren
fig.show()
```

# Oppgaver

### Oppgave 1 - üìà Simulering av aksjekurs  
En aksjekurs beveger seg tilfeldig over tid. Vi antar at aksjen starter p√• **100 kroner** og endrer seg tilfeldig for hver tidsperiode.  

- **Lag en simulering av aksjekursen over 100 dager**  
- Hver dag endrer aksjekursen seg med en tilfeldig verdi mellom -3% og +3%  
- Plott kursutviklingen  

*Tips: Bruk en for-l√∏kke og lagre verdiene i en liste! * 

Koden kan gjerne starte noe ala dette:

```python
# Parametere
days = 100
price = 100
prices = [price]

# Fortsett koden under - simulering og plotting
```


### Oppgave 2 - üè¢ Simulering av bedriftens overskudd 
En bedrift selger **Q** produkter til pris **p**, og produksjonskostnaden per enhet er **C**.  
Overskuddet beregnes som:  

$\text{Overskudd} = Q \cdot p - Q \cdot C$

**Lag en simulering der**:  
- **Q** varierer mellom 900 og 1100  
- **p** varierer mellom 90 og 110  
- **C** varierer mellom 50 og 70  

* Kj√∏r simuleringen **1000 ganger**  
* Plott histogram av overskuddet  

*Tips: Bruk numpy for √• generere tilfeldige verdier!*  


### Oppgave 3 - üí∞ Simulering av l√•nekostnader  
Du tar opp et boligl√•n p√• **2 000 000 kr**. Renten er i utgangspunktet **3%**, men den varierer tilfeldig mellom **2% og 5%** hvert √•r.  

- **Simuler utviklingen i l√•nekostnader over 30 √•r**  
- Beregn den totale rentekostnaden etter 30 √•r  
- Kj√∏r simuleringen **500 ganger**, og plott fordelingen av totale rentekostnader


### Oppgave 4 - üì¶ Simulering av lagerstyring og ettersp√∏rsel  
Et selskap h√•ndterer en vare med en ukentlig ettersp√∏rsel som varierer mellom **80 og 120 enheter**.  
De bestiller varer hver uke basert p√• en prognose, men **det er alltid en usikkerhet p√• ¬±10% i ettersp√∏rselen**.  

- **Simuler lagerbeholdning over 52 uker**  
- Start med et lager p√• **500 enheter**  
- Hvis lageret g√•r under **100 enheter**, bestilles **200 nye enheter**  
- Plott utviklingen i lagerbeholdning over tid


# Oppgave 5 - Simuleringer üí∞üé≤üí∞
Du er p√• tur med vennegjengen din p√• casino i Monaco, og spiller et (fiktivt) terningspill. 

Du vet at en vanlig terning f√∏lger en $\textit{diskret uniform fordeling}$, hvor det er like stor sannsynlighet for hvert $\textit{utfall}$ (alts√• om terningen viser $1, \; 2, \; 3, \; 4, \; 5$ eller $6$).

I statistikk, snakker vi ofte om $\textit{forventningsverdi}$ (skrives $E[X]$), som sier noe om hva vi forventer en tilfeldig variabel $X$ vil v√¶re. For diskret problemer er det definert som 
$$E[X] = \sum_{i=1}^{n}x_i \cdot P(X=x_i)$$

hvor $x_i$ er verdien av terningen, og $P(X=x_i)$ er sannsynligheten for √• f√• verdien $x_i$ p√• et kast. Vi vet at $n=6$, ettersom det er $6$ ulike utfall av en terning. Da kan vi skrive det ut slik:
$$E[X] = 1 \cdot \frac{1}{6} + 2 \cdot \frac{1}{6} + \cdots + 6 \cdot \frac{1}{6}$$
regner vi ut dette ser vi at vi f√•r
$$E[X] =3,5$$ 

Dermed er forventningsverdien til en terning lik $3,5$.

## Case
I dette fiktive terningsspillet i Monaco skal man trille to terninger, samtidig. Man vinner spillet hvis summen av de to terningene er *over eller lik* $9$. 
Du kommer p√• at du kan simulere utfall ved hjelp av Python og Numpy.

## Oppgave 5.1
Bruk simulering, til √• finne ut sannsynligheten for at du triller to treninger med sum $\textbf{over eller lik}$ $9$. 
- Visualiser utfallene ved bruk av et histogram.
- Antall simuleringer skal dere velge selv, men kommenter hvorfor dere velger som dere gj√∏r.
- Under er et lite kodehint for hva dere kan ta i bruk.
```python
        # Mulige bibliotek for oppgaven.
        import numpy as np
        import matplotlib.pyplot as plt
        import random

        # Du kan f√• bruk for funksjonen (hvor argumentene m√• spesifiseres i henhold til oppgaven). Hvor low = inkludert, high = ekskludert.
        np.random.randint(low, high=None, size=None, dtype=int)
```

## Oppgave 5.2
Finn ut hvor mange kast av to terninger m√• du ta ($n$) for at sannsynligheten for √• f√• en sum over eller lik $9$ minst √©n gang er over $90$%. 

Hint - formelen for √• finne sannsynligheten for at summen er over eller lik 9, minst √©n gang er gitt som f√∏lgende:
$$P(\text{summen} \geq 9 \text{ minst √©n gang}) = 1 - \left(P(\text{summen} < 9)\right)^n$$

hvor $P\left(\text{summen} < 9\right)$ kan finnes fra simuleringen over.

Bruk ```sympy``` for √• l√∏se dette problemet, og si hvor mange ganger ($n$) vi m√• trille terningen.


