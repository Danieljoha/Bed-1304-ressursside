---
title: '[< Forrige](3%20-%20Funksjoner.ipynb)     |     [Neste >](5%20-%20Pandas_og_databehandling.ipynb)'
jupyter: python3
---



<span style="color:#9bb1d4;font-size:30px;font-weight:900"> 4 - lister, oppslag og numpy </span>  

En liste er en *datastruktur*, som igjen er en organisering av *objekter*. Slike datastrukturer er helt sentralt i alle programmeringsspr√•k, og alle spr√•k har ulike typer strukturer til ulike form√•l. I noen datastrukturer kan du putte alle typer objekter sammen, slik som tekst, funksjoner og tall og nye datastrukturer. 

I andre datastrukturer kan du kun putte tall. Slike datastrukturer er vanligvis det vi i matematikken kaller *vektorer* og *matriser*. Disse kommer vi tilbake til n√•r vi skal snakke om Numpy. 

Det vi skal se p√• f√∏rst er de innebygde datastrukturene til Python. Alle de innebygde strukturene kan inneholde alle typer objekter, men de har noen viktige egenskaper som skiller dem:
* `list` (liste): Hvert element har en bestemt plassering i listen, Tilgang f√•s ved √• referere til plasseringen (indeksen) i form av et heltall `int`. 
* `tuple`: Lik lister, men kan ikke forandres n√•r den er skapt. Hovedsakelig til bruk i forbindelse med funksjoner.
* `dict`(dictionary, oppslag): Elementene har ikke en bestemt plassering. Tilgang f√•s ved √• referere til en n√∏kkel (vanligvis en streng `str`)

Vi starter med √• se p√• **lister**.

# Lister

Lister lages med klammeparenteser. Her er noen lister med navn, forkortelse (Ticker), aksjekurs, markedsverdi, PE og gjeldsgrad for noen aksjer p√• Oslo B√∏rs. Tallene er fra 27. november 2020 (kilde https://titlon.uit.no). 

PE er "Price/Earnings", som er forholdet mellom selskapenes inntjening og prisen. Gjeldsgrad er hvor stor andel av total kapital som er gjeld. Det som ikke er gjeld er egenkapital. 

#### Eksempel 1:

```{python}
# Listene best√•r av [Navn, ticker, aksjekurs, markedsverdi, P/E, gjeldsrate]

equinor=['Statoil', 'EQNR', 167.554919090282, 376883380048.5, 6.14609823076753, 0.617893838660362]
dnb=['DNB', 'DNB', 164, 259169427140, 11.1121822724349, 0.914999939276725]
telenor=['Telenor', 'TEL', 148.737572948101, 227115017138.4, 13.0211568133471, 0.715300723576896]
marine_harvest=['Marine Harvest', 'MHG', 225.589705235372, 118004750966.2, 21.6878893009616, 0.440427599611273]
aker_bp=['Aker BP', 'AKERBP', 272.499264741749, 103712690592, 26.7636558040214, 0.722568840028356]
yara_international=['Yara International', 'YAR', 333.328922090651, 99481443032.4, 86.741957363663, 0.465057636887608]
gjensidige_forsikring=['Gjensidige Forsikring', 'GJF', 172.830508474576, 92125000000, 24.9404407385348, 0.847890127134592]
```

Vi kan n√• f√• tilgang til listene ved √• referere til plasseringen med klammeparentes. Om vi vil referere navnet til equinor, som ligger p√• plass 0, kan vi for eksempel skrive `equinor[0]` (f√∏rste element er alltid p√• plass 0 i Python):

```{python}
equinor[0]
```

```{python}
type(equinor[0])
```

```{python}
equinor[1]
```

```{python}
len(equinor)
```

```{python}
equinor[-2]
```

Vi ser at navnet er feil, dette er det gamle navnet til Equinor. Dette kan vi enkelt endre ved √• sette element 0 i `equinor`-listen lik `'Equinor'`:

#### Eksempel 2:

```{python}
print(equinor)
equinor[0]='Equinor'
print(equinor)
```

Men vi kan legge hvilke som helst objekter inn i en liste, s√• vi kan ogs√• lage en liste av listene over.

#### Eksempel 3:

```{python}
stocks=[equinor,dnb,telenor,marine_harvest,aker_bp,yara_international,gjensidige_forsikring]
stocks
```

```{python}
stocks[4][0]
```

Aker BP-askjen er element nummer fem i denne listen. Om vi n√• skal referere til den, s√• bruker vi indeks 4, siden vi starter p√• null. 

#### Eksempel 4:

```{python}
stocks[4]
```

Om du vil referere til siste element, bruker du indeks -1. Vil du referere til nest siste, bruker du indeks -2, og s√• videre:

#### Eksempel 5:

```{python}
#| scrolled: true
print(stocks[-1])
print(stocks[-2])
```

Du kan ogs√• referere til flere elementer som st√•r ved siden av hverandre med en s√•kalt `slice`, eller skj√¶re som vi kan kalle det p√• norsk:

#### Eksempel 6:

```{python}
stocks
```

```{python}
# Fra element to til og med tre:
stocks[2:4]
```

```{python}
# Fra og med nest siste element:
stocks[-2:]
```

```{python}
stocks[-2]
```

```{python}
# Til og med nest siste element:
stocks[:-1]
```

Og vi kan referere til en liste inne i en liste:

#### Eksempel 7:

```{python}
print(f"Det tredje selskapet er {stocks[2][0]}")
```

Det tredje selskapet, alts√• Telenor, har indeks to, siden Python starter indekseringen p√• 0. 

Det er enkelt √• utvide lister, vi bruker bare `+`. Om vi for eksempel vil legge til selskapet `['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939] `, kan vi gj√∏re det slik:

#### Eksempel 8:

```{python}
tomra_systems=['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939]

stocks = stocks + [tomra_systems]
stocks
```

```{python}
# N√• kan vi se hva lengen av lista v√•r 'stocks' har blitt til
len(stocks)
```

# Unng√• u√∏nsket endring av objekter

En veldig vanlig nybegynnerfeil i Python er √• glemme at selv om et objekt, slik som en liste, har f√•tt nytt navn, s√• er det fortsatt det samme objektet. Dette er spesielt lett √• glemme n√•r du objektet er et argument i en funksjon. Her er for eksempel en funksjon som opererer p√• argumentet:

#### Eksempel 9:

```{python}
# Denne funksjonen kvitter seg med element i i en liste 
def pop_and_print(liste, i):
    element_i = liste.pop(i)
    print(element_i)
    
pop_and_print(stocks, 1)
stocks
```

Over brukes `pop`-metoden til listeobjektet. En "metode" er en funksjon som kan henges p√• et bestemt objekt. Liste-objektet har alts√• en metode `pop`, som vi kan henge p√• listeobjektet med et punktum. `pop`-metoden fjerner elementet angitt av argumentet (siste element `-1` i eksemplet under), og returnerer det fjernede elementet. 

Kj√∏rer du koden over mange nok ganger, vil du se at alle elementene til slutt er borte og du f√•r feilmelding. 

Av og til vil du at funksjonen skal operere p√• argumentet, men om det ikke er meningen at argumentet skal v√¶re endret n√•r funksjonen er ferdigkj√∏rt, s√• kan du ta en kopi inne i funksjonen. Det gj√∏res enklest ved √• bruke *typen* til objektet som funksjon. Du danner da et nytt objekt av samme type. For eksempel for en liste som `stocks`bruker du `list`som funksjon

#### Eksempel 10:

```{python}
# Denne funksjonen kvitter seg med element i
def pop_and_print(a,i):
    # Lag en kopi av liste 'a'
    a=list(a)
    
    # Kvitter oss med element i, og viser hva det er
    last_element=a.pop(i)
    print(last_element)
    
pop_and_print(stocks,-2)
#stocks
```

Denne koden kan kj√∏res s√• mange ganger du vil, uten at stocks endres.

# Tuple

En `tuple` fungerer ganske likt som en liste n√•r du skal hente noe fra den. Men i motsetning til en liste, s√• g√•r det ikke an √• endre p√• en `tuple` etter at den er skapt. Du kan lage en tuple enten ved √• bruke den innebygde funksjonen  `tuple()` eller ved √• lage en liste med en vanlig parentes:

#### Eksempel 11:

```{python}
a = tuple(equinor)
b = ('Equinor', 'EQNR', 146.85, 315357973561)

print(type(a))
print(type(b))
```

```{python}
print(dnb)
print(type(dnb))
```

```{python}
DNB_tuple = tuple(dnb)
print(DNB_tuple)
print(type(DNB_tuple))
```

Vi kan *f√• tak i* innholdet, men det g√•r ikke an √• *endre* p√• innholdet i en `tuple`etter at den er skapt:

#### Eksempel 12:

```{python}
#| scrolled: true
print(a[0])
a[0]='Statoil'
```

* Tuple er mest brukt i forbindelse med funksjoner, og er ikke noe vi kommer til √• bruke mye tid p√• i dette kurset. 
* En annen fordel med 'tuples' er at de er mer effektive ved sv√¶rt store datasett.

# Numpy

NumPy ([*"numerical Python"*]()) er en pakke som kan gj√∏re matematiske beregninger p√• store datasett, p√• en sv√¶rt effektiv m√•te. Vi starter med √• importere pakken, og konvertere listen vi har brukt til en numpy-matrise kalt `ndarray`. En *matrise* er en liste der alle rader har like mange elementer, og det er jo tilfelle med v√•r `stocks`-liste.

# Hva er et array?

I programmering er et **array** en struktur for √• lagre og hente ut data.  
Man kan se for seg et array som et rutenett, der hver celle inneholder ett element av data.  

- Et **en-dimensjonalt array** kan sammenlignes med en liste:  
  `[1, 2, 3, 4]`

- Et **to-dimensjonalt array** ligner en tabell (rader og kolonner). 

| 1 | 2 | 3 | 4 |
|---|---|---|---|
| 5 | 6 | 7 | 8 |
| 9 |10 |11 |12 |

- Et **tre-dimensjonalt array** kan tenkes som flere tabeller lagt opp√• hverandre, som sider i en bok.  

I **NumPy** generaliseres denne ideen til et vilk√•rlig antall dimensjoner. Den grunnleggende array-klassen heter derfor `ndarray` (**N-dimensjonalt array**).

---

## Restriksjoner i NumPy-arrays
NumPy-arrays har noen begrensninger sammenlignet med vanlige Python-lister:

1. Alle elementene m√• v√¶re av **samme datatype**.  
2. N√•r et array er opprettet, kan **st√∏rrelsen ikke endres**.  
3. Formen m√• v√¶re **rektangul√¶r**, ikke "taggete" (f.eks. kan ikke en rad ha flere kolonner enn en annen).

Disse reglene gj√∏r at NumPy kan v√¶re **raskere**, bruke **mindre minne**, og gi mer praktiske verkt√∏y for beregninger enn vanlige datastrukturer i Python.

---

## Opprette arrays
Et array kan lages fra en Python-liste. For eksempel:

```python
import numpy as np

a = np.array([1, 2, 3, 4, 5, 6])
print(a)
# array([1, 2, 3, 4, 5, 6])

### **Tilgang til elementer**

Elementer kan hentes ut med indeksering, p√• samme m√•te som i en liste:

```python
a[0]
```

### **Arrays er mutable (kan endres)**
Akkurat som lister i Python, kan elementene endres:
```python
a[0] = 10
print(a)
```

### **Slicing**

Man kan hente ut deler av et array med slice-notasjon:

```python
a[:3]
```
#### **OBS**
En viktig forskjell fra lister er at slicing i NumPy gir en **view** (en peker til originaldata), ikke en kopi.
Det betyr at endringer i view ogs√• p√•virker det originale arrayet:

```python
b = a[3:]
print(b)
# array([4, 5, 6])

b[0] = 40
print(a)
# array([10,  2,  3, 40,  5,  6])
```

# Hvorfor bruke NumPy-arrays i stedet for lister?

Selv om Python-lister er fleksible og enkle √• bruke, har de noen begrensninger n√•r det gjelder store datamengder og numeriske beregninger.  
NumPy-arrays (`ndarray`) er laget for vitenskapelige beregninger og har derfor flere fordeler:

- üöÄ **Ytelse**: NumPy er skrevet i C under panseret, og array-operasjoner er mye raskere enn tilsvarende l√∏kker i Python.  
- üì¶ **Minnebruk**: Alle elementene i et NumPy-array har samme datatype og ligger lagret i sammenhengende minne ‚Üí mer kompakt og effektiv lagring enn lister.  
- üî¢ **Matematiske operasjoner**: NumPy st√∏tter vektoriserte operasjoner (regning p√• hele arrays samtidig) uten eksplisitte l√∏kker.  
- üß© **Verkt√∏ykasse**: NumPy gir tilgang til mange funksjoner for line√¶r algebra, statistikk, transformasjoner m.m. som ikke finnes i vanlige lister.  
- üìê **Flere dimensjoner**: Arrays kan v√¶re 1D (liste), 2D (matrise/tabell) eller h√∏yere dimensjoner (f.eks. 3D for bilder, 4D for datasett i maskinl√¶ring).

Kort sagt: NumPy-arrays er **raskere, mer effektive og mer praktiske** n√•r man skal jobbe med data og tall.

```{python}
# kvadratrot av liste ved hjelp av numpy

import numpy as np
a = [1, 4, 9, 16, 25]
b = np.sqrt(a)
print(b)
print(type(b))
print(b[2])
print(type(b[2]))
```

#### Eksempel 13:

Vi starter med √• definere en liste av liste med informasjon om aksjene:

```{python}
import numpy as np
```

```{python}
stocks=[
['Equinor', 'EQNR', 167.554919090282, 376883380048.5, 6.14609823076753, 0.617893838660362] , 
['DNB', 'DNB', 164, 259169427140, 11.1121822724349, 0.914999939276725] , 
['Telenor', 'TEL', 148.737572948101, 227115017138.4, 13.0211568133471, 0.715300723576896] , 
['Marine Harvest', 'MHG', 225.589705235372, 118004750966.2, 21.6878893009616, 0.440427599611273] , 
['Aker BP', 'AKERBP', 272.499264741749, 103712690592, 26.7636558040214, 0.722568840028356] , 
['Yara International', 'YAR', 333.328922090651, 99481443032.4, 86.741957363663, 0.465057636887608] , 
['Gjensidige Forsikring', 'GJF', 172.830508474576, 92125000000, 24.9404407385348, 0.847890127134592] , 
['Orkla', 'ORK', 86.5857852597003, 89087299091.2, 26.5615083754323, 0.350968405416214] , 
['Norsk Hydro', 'NHY', 31.4389402413895, 67532103728.64, 15.6215830970715, 0.439195576287418] , 
['SalMar', 'SALM', 449.3, 50905689550.7, 14.222545257898, 0.396134627028104] , 
['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939] , 
['Aker', 'AKER', 514.200494811093, 40393931997, 43.4343354806452, 0.548092886866901] , 
]
```

```{python}
stocks[1]
```

Som du ser, s√• best√•r listen av tolv rader og seks kolonner. Dette er alts√• en 12x6-matrise. Den kan enkelt konverteres til en numpy-matrise med funksjonen `np.array()` slik som her:

#### Eksempel 14:

```{python}
#| scrolled: true
stocks_np = np.array(stocks)
```

```{python}
type(stocks_np)
```

Her ser vi at datatypen er `numpy.ndarray`, som vi nevnte over.

```{python}
stocks_np
```

Listen er n√• lagret som en numpy 12x6-matrise i objektet `stocks_np`. Vi kan imidlertid ikke utf√∏re noen matematiske beregninger slik denne matrisen st√•r, fordi alle tall er i tekstformat. Som vi har sett tidligere g√•r det bare an √• regne med `float`, `int` og `bool`. At det er tekst ser vi ved at det er enkle anf√∏rselstegn `'` rundt alle elementene. 

Heldigvis er det veldig enkelt √• hente ut informasjon fra numpy-matriser, fordi mulighetene til √• skj√¶re utsnitt er langt st√∏rre enn for vanlige lister. Numpy-lister kan nemlig skj√¶res i flere dimensjoner. 

I motsetning til vanlige lister, kan vi for eksempel velge ut kolonner. I en liste av lister velger du, som vi har sett, rad 2 og kolonne 0 med `stocks[2][0]`. Med numpy-matriser separerer du de to indeksene med et komma, `stocks[2,0]`.

Men enda viktigere, du kan velge alle elementer ved √• sette inn kolon `:` i stedet for tall. Dermed kan du velge hele kolonne 0 med `stocks_np[:,0]`.

Her er vi mest interessert i de to siste kolonnene. Det er disse som inneholder tall. For √• plukke ut disse velger vi alle radene (`:`) og alle kolonnene fra og med kolonne 2 (`2:`). Da f√•r vi

#### Eksempel 15:

```{python}
stocks_np[:,2:]
```

Sist i matrisen over, st√•r det `dtype='<U32'`. Det betyr at dette er tekstrenger p√• 32 eller f√¶rre tegn. Vi m√• imidlertid ha dette over i tallformat for √• kunne jobbe med det. Det gj√∏r vi slik:

#### Eksempel 16:

```{python}
stocks_numbers = np.array(stocks_np[:,2:], dtype = float)
stocks_numbers
```

N√•r vi konverterte listen til en `ndarray`, s√• brukte vi alts√• funksjonen `np.array()`, slik som i Eksempel 14. Men denne gangen legger vi til det valgfrie argument `dtype=float` for √• eksplisitt gi beskjed om at vi √∏nsker strengene konvertert til flyttall. 

N√• kan vi begynne √• bruke tallene. For eksempel kan vi se grafisk om det er en sammenheng mellom gjeldsgrad og pris-inntjeningstraten (PE). Dette er de to siste kolonnene i datamatrisen:

#### Eksempel 17:

```{python}
from matplotlib import pyplot as plt

fig,ax = plt.subplots()
ax.set_ylabel('PE')
ax.set_xlabel('gjeldsrate')
ax.scatter(stocks_numbers[:,-1], stocks_numbers[:,-2])
plt.grid(True)

plt.show()
```

Ser du en sammenheng?

Det er ogs√• enkelt √• regne med Numpy. Vi kan bruke alle de vanlige regneartene med numpy-matriser:

```{python}
a = np.array([1,5,6,3])
b = np.array([23,15,2,10])

print(a+b)
print(a-b)
print(a*b)
print(a/b)
print(a**3)
print(a**0.5) #Kvadratroten
```

# Oppslag

Et oppslag, eller *dictionary* har symbol `dict` i Python. Dette er en datastruktur der hvert element ikke identifiseres med hvor det er plassert, men med et n√∏kkelord (`key`). √Ö bruke oppslag i stedet for lister gj√∏r ofte koden mer lesbar. Det finnes to m√•ter √• lage oppslag p√•; enten ved √• bruke funksjonen `dict()`:

#### Eksempel 18:

```{python}
# Definere en tom dictionary kalt a
a = dict()

# Gjeldsrate er i siste kolonne av stocks_numbers ndarray, alts√• indeks '-1'
a['gjeldsrate'] = stocks_numbers[:,-1]

# PE er i nest siste kolonne av stocks_numbers ndarray, alts√• indeks '-2'
a['PE'] = stocks_numbers[:,-2]

print(a)
print(type(a))
```

```{python}
a['gjeldsrate']
```

Som vi ser, blir dette et objekt av type `dict`. Alternativt kan vi definere elementer inne i en kr√∏lleparentes p√• formen `{n√∏kkel: objekt}`, slik som dette:

```{python}
b={
    'gjeldsrate':stocks_numbers[:,-1],
    'PE':stocks_numbers[:,-2], 
  }

print(type(b))
```

Her er det alts√• to elementer med n√∏kler `'gjeldsrate'` og `'PE'`, og tilh√∏rende objekter fra `stocks_numbers`. 

Vi legger merke til at dette ogs√• er en objekt av type `dict`. Med oppslag blir det enklere √• bruke variablene, siden vi kan referere til dem med navn i stedet for indeks. Her er plottet i Eksempel 17 gjort med oppslag:

#### Eksempel 19:

```{python}
#| scrolled: true
plt.ylabel('PE')
plt.xlabel('gjeldsrate')
plt.scatter(a['gjeldsrate'], a['PE'])
```

N√•r du f√∏rst har laget en dict, er det enkelt √• legge til nye elementer. Det gj√∏r du enkelt ved √• bruke en n√∏kkel som ikke finnes, for eksempel `'Pris'`, og dette elementet lik √∏nsket objekt:

#### Eksempel 20:

```{python}
a['Pris']=stocks_numbers[:,0]
plt.ylabel('Pris')
plt.xlabel('gjeldsrate')
plt.scatter(a['gjeldsrate'], a['Pris'])
```

`dict`-objektet er helt sentralt i selve byggeklossene til Python. Alle variabler du lager er faktisk elementer i to `dict` som du kan f√• frem med funksjonene `locals()` og `globals()`, som kaller de lokalt og globalt definerte variablene i milj√∏et du befinner deg. Dette eksemplet viser at objektet `stocks` som vi har definert i Eksempel 13, er identisk med elementet `'stocks'` i `locals()`.

#### Eksempel 21:

```{python}
locals()['stocks']==stocks
```

Vi ser at disse objektene egentlig er det samme, ved at den logiske testen om disse er like, returnerer sann (`True`).

# Oppgaver

Det er enkelt √• konvertere en pandas dataramme til numpy. Vi skal bruke et datasett som heter 'schooling-gdp.csv', som er en Excel-fil. Vi henter inn dataene og konverterer dem til numpy slik:

```{python}
import pandas as pd
```

```{python}
# Dette kan dere kj√∏re som det er, vi skal se mer p√• pandas i neste forelesning!
url = "https://raw.githubusercontent.com/uit-bed-1304-h25/uit-bed-1304-h25.github.io/refs/heads/main/data/schooling-gdp.csv"
df = pd.read_csv(url)

# Gj√∏r om en pandas dataframe til numpy
numpy_data = df.to_numpy()

# Dette er dataene vi skal jobbe med i oppgaver. Mer om Pandas og databehandling i neste forelesning
numpy_data
```

1. Bytt ut navnet til "Ireland" med "Republic of Ireland" og "United States" med "United States of America"

**Hint:**
* Husk √• bruk riktig indeksering for √• finne "Ireland" og "United States"
```python 
numpy_data[i][j] = 'Republic of Ireland'
```

hvor du m√• finne tallene *i* og *j*.


2. Print data for "Luxembourg"


3. Print data for "Liberia" ved √• referere til nest siste element. 


4. Print BNP per capita for de tre siste elementene i `schooling` (ligger i kolonne med indeks 2)


5. Print BNP per capita for de tre siste elementene i `schooling` men hent kolonnen ved √• refere til tredje siste kolonne. 


6. Plukk ut de tre siste kolonnene i `schooling`, som representerer BNP per capita, skolegang og befolkning, og konverter dem til datatype `float`. 



7. Lag et oppslag (dictionary) med de tre siste kolonnene og passende navn som n√∏kler. Kall det `schooling_dict`. 


8. Lag en ny variabel i oppslaget med navn "Total schooling" som er produktet av skolegang og befolkning.


9. Lag en ny variabel "Total GDP" som er produktet av BNP per capita og befolkning. 


10. Lag et scatterplot med de to variablene du nettopp lagde. 


11. Lag plottet over, men konverter variablene med np.log()


12. Lag en ny variabel "GDP per schooling" som er BNP per capita delt p√• skolegang.


13. Lag et liggende stolpediagram med navn p√• land og "GDP per schooling". Du bruker da funksjonen `plt.barh` p√• denne m√•ten:
```
plt.barh(names,values)
```
Hvor `names` er en liste med navnene og `values` er de tilh√∏rende verdiene. 



14. Dette blir ikke pent. Velg kun de 20 f√∏rste landene, og fors√∏k p√• nytt. 


15. med argsort f√•r du rangeringen til etter en sortering. Her er rangeringen for "GDP per schooling"


`[::-1]` til slutt s√∏rger for √• reversere sorteringen. Legg referansen til soreringen inn i variabelen `sorted`, og lag diagrammet p√• nytt med sorterte verdier. Om du har en numpy-liste a, kan du velge de sorterte verdiene med `a[sorted]`

Lag

a) et nytt diagram med alle landene og

b) et diagram med de 20 √∏verste.

c) et diagram med de 20 nederste




##### [< Forrige](3%20-%20Funksjoner.ipynb)     |     [Neste >](5%20-%20Pandas_og_databehandling.ipynb)

