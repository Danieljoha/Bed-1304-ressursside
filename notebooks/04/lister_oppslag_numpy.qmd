---
title: '4 - Lister, oppslag og numpy'
jupyter:
  kernelspec:
    display_name: Python (myenv)
    language: python
    name: myenv
---



En liste er en *datastruktur*, som igjen er en organisering av *objekter*. Slike datastrukturer er helt sentralt i alle programmeringsspråk, og alle språk har ulike typer strukturer til ulike formål. I noen datastrukturer kan du putte alle typer objekter sammen, slik som tekst, funksjoner og tall og nye datastrukturer. 

I andre datastrukturer kan du kun putte tall. Slike datastrukturer er vanligvis det vi i matematikken kaller *vektorer* og *matriser*. Disse kommer vi tilbake til når vi skal snakke om Numpy. 

Det vi skal se på først er de innebygde datastrukturene til Python. Alle de innebygde strukturene kan inneholde alle typer objekter, men de har noen viktige egenskaper som skiller dem:
* `list` (liste): Hvert element har en bestemt plassering i listen, Tilgang fås ved å referere til plasseringen (indeksen) i form av et heltall `int`. 
* `tuple`: Lik lister, men kan ikke forandres når den er skapt. Hovedsakelig til bruk i forbindelse med funksjoner.
* `dict`(dictionary, oppslag): Elementene har ikke en bestemt plassering. Tilgang fås ved å referere til en nøkkel (vanligvis en streng `str`)

Vi starter med å se på **lister**.

## Lister

Lister lages med klammeparenteser. Her er noen lister med navn, forkortelse (Ticker), aksjekurs, markedsverdi, PE og gjeldsgrad for noen aksjer på Oslo Børs. Tallene er fra 27. november 2020 (kilde https://titlon.uit.no). 

PE er "Price/Earnings", som er forholdet mellom selskapenes inntjening og prisen. Gjeldsgrad er hvor stor andel av total kapital som er gjeld. Det som ikke er gjeld er egenkapital. 

#### Eksempel 1:

```{python}
equinor=['Statoil', 'EQNR', 167.554919090282, 376883380048.5, 6.14609823076753, 0.617893838660362]
dnb=['DNB', 'DNB', 164, 259169427140, 11.1121822724349, 0.914999939276725]
telenor=['Telenor', 'TEL', 148.737572948101, 227115017138.4, 13.0211568133471, 0.715300723576896]
marine_harvest=['Marine Harvest', 'MHG', 225.589705235372, 118004750966.2, 21.6878893009616, 0.440427599611273]
aker_bp=['Aker BP', 'AKERBP', 272.499264741749, 103712690592, 26.7636558040214, 0.722568840028356]
yara_international=['Yara International', 'YAR', 333.328922090651, 99481443032.4, 86.741957363663, 0.465057636887608]
gjensidige_forsikring=['Gjensidige Forsikring', 'GJF', 172.830508474576, 92125000000, 24.9404407385348, 0.847890127134592]
```

Vi kan nå få tilgang til listene ved å referere til plasseringen med klammeparentes. Om vi vil referere navnet til equinor, som ligger på plass 0, kan vi for eksempel skrive `equinor[0]` (første element er alltid på plass 0 i Python):

```{python}
equinor[0]
```

```{python}
type(equinor[0])
```

```{python}
equinor[1]
```

```{python}
len(equinor)
```

```{python}
equinor[-2]
```

Vi ser at navnet er feil, dette er det gamle navnet til Equinor. Dette kan vi enkelt endre ved å sette element 0 i `equinor`-listen lik `'Equinor'`:

#### Eksempel 2:

```{python}
print(equinor)
equinor[0]='Equinor'
print(equinor)
```

Men vi kan legge hvilke som helst objekter inn i en liste, så vi kan også lage en liste av listene over.

#### Eksempel 3:

```{python}
stocks=[equinor,dnb,telenor,marine_harvest,aker_bp,yara_international,gjensidige_forsikring]
stocks
```

```{python}
stocks[4][0]
```

Aker BP-askjen er element nummer fem i denne listen. Om vi nå skal referere til den, så bruker vi indeks 4, siden vi starter på null. 

#### Eksempel 4:

```{python}
stocks[4]
```

Om du vil referere til siste element, bruker du indeks -1. Vil du referere til nest siste, bruker du indeks -2, og så videre:

#### Eksempel 5:

```{python}
#| scrolled: true
print(stocks[-1])
print(stocks[-2])
```

Du kan også referere til flere elementer som står ved siden av hverandre med en såkalt `slice`, eller skjære som vi kan kalle det på norsk:

#### Eksempel 6:

```{python}
stocks
```

```{python}
# Fra element to til og med tre:
stocks[2:4]
```

```{python}
# Fra og med nest siste element:
stocks[-2:]
```

```{python}
stocks[-2]
```

```{python}
# Til og med nest siste element:
stocks[:-1]
```

Og vi kan referere til en liste inne i en liste:

#### Eksempel 7:

```{python}
print(f"Det tredje selskapet er {stocks[2][0]}")
```

Det tredje selskapet, altså Telenor, har indeks to, siden Python starter indekseringen på 0. 

Det er enkelt å utvide lister, vi bruker bare `+`. Om vi for eksempel vil legge til selskapet `['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939] `, kan vi gjøre det slik:

#### Eksempel 8:

```{python}
tomra_systems=['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939]

stocks = stocks + [tomra_systems]
stocks
```

```{python}
# Nå kan vi se hva lengen av lista vår 'stocks' har blitt til
len(stocks)
```

# Unngå uønsket endring av objekter

En veldig vanlig nybegynnerfeil i Python er å glemme at selv om et objekt, slik som en liste, har fått nytt navn, så er det fortsatt det samme objektet. Dette er spesielt lett å glemme når du objektet er et argument i en funksjon. Her er for eksempel en funksjon som opererer på argumentet:

#### Eksempel 9:

```{python}
# Denne funksjonen kvitter seg med element i i en liste 
def pop_and_print(liste, i):
    last_element = liste.pop(i)
    print(last_element)
    
pop_and_print(stocks, 1)
stocks
```

Over brukes `pop`-metoden til listeobjektet. En "metode" er en funksjon som kan henges på et bestemt objekt. Liste-objektet har altså en metode `pop`, som vi kan henge på listeobjektet med et punktum. `pop`-metoden fjerner elementet angitt av argumentet (siste element `-1` i eksemplet under), og returnerer det fjernede elementet. 

Kjører du koden over mange nok ganger, vil du se at alle elementene til slutt er borte og du får feilmelding. 

Av og til vil du at funksjonen skal operere på argumentet, men om det ikke er meningen at argumentet skal være endret når funksjonen er ferdigkjørt, så kan du ta en kopi inne i funksjonen. Det gjøres enklest ved å bruke *typen* til objektet som funksjon. Du danner da et nytt objekt av samme type. For eksempel for en liste som `stocks`bruker du `list`som funksjon

#### Eksempel 10:

```{python}
# Denne funksjonen kvitter seg med element i
def pop_and_print(a,i):
    # Lag en kopi av liste 'a'
    a=list(a)
    
    # Kvitter oss med element i, og viser hva det er
    last_element=a.pop(-1)
    print(last_element)
    
pop_and_print(stocks,-1)
stocks
```

Denne koden kan kjøres så mange ganger du vil, uten at stocks endres

# Tuple

En `tuple` fungerer ganske likt som en liste når du skal hente noe fra den. Men i motsetning til en liste, så går det ikke an å endre på en `tuple` etter at den er skapt. Du kan lage en tuple enten ved å bruke den innebygde funksjonen  `tuple()` eller ved å lage en liste med en vanlig parentes:

#### Eksempel 11:

```{python}
a = tuple(equinor)
b = ('Equinor', 'EQNR', 146.85, 315357973561)

print(type(a))
print(type(b))
```

```{python}
print(dnb)
print(type(dnb))
```

```{python}
DNB_tuple = tuple(dnb)
print(DNB_tuple)
print(type(DNB_tuple))
```

Vi kan *få tak i* innholdet, men det går ikke an å *endre* på innholdet i en `tuple`etter at den er skapt:

#### Eksempel 12:

```{python}
#| scrolled: true
print(a[0])
a[0]='Statoil'
```

Tuple er mest brukt i forbindelse med funksjoner, og er ikke noe vi kommer til å bruke mye tid på i dette kurset. En annen fordel med 'tuples' er at de er mer effektive ved svært store datasett.

# Numpy

Numpy er en pakke som kan gjøre matematiske beregninger på store datasett, , på en svært effektiv måte. Vi starter med å importere pakken, og konvertere listen vi har brukt til en numpy-matrise kalt `ndarray`. En *matrise* er en liste der alle rader har like mange elementer, og det er jo tilfelle med vår `stocks`-liste.

Vi starter med å definere en liste av liste med informasjon om aksjene:

#### Eksempel 13:

```{python}
import numpy as np
```

```{python}
stocks=[
['Equinor', 'EQNR', 167.554919090282, 376883380048.5, 6.14609823076753, 0.617893838660362] , 
['DNB', 'DNB', 164, 259169427140, 11.1121822724349, 0.914999939276725] , 
['Telenor', 'TEL', 148.737572948101, 227115017138.4, 13.0211568133471, 0.715300723576896] , 
['Marine Harvest', 'MHG', 225.589705235372, 118004750966.2, 21.6878893009616, 0.440427599611273] , 
['Aker BP', 'AKERBP', 272.499264741749, 103712690592, 26.7636558040214, 0.722568840028356] , 
['Yara International', 'YAR', 333.328922090651, 99481443032.4, 86.741957363663, 0.465057636887608] , 
['Gjensidige Forsikring', 'GJF', 172.830508474576, 92125000000, 24.9404407385348, 0.847890127134592] , 
['Orkla', 'ORK', 86.5857852597003, 89087299091.2, 26.5615083754323, 0.350968405416214] , 
['Norsk Hydro', 'NHY', 31.4389402413895, 67532103728.64, 15.6215830970715, 0.439195576287418] , 
['SalMar', 'SALM', 449.3, 50905689550.7, 14.222545257898, 0.396134627028104] , 
['Tomra Systems', 'TOM', 276.409619134278, 41208789715.2, 52.8996016883184, 0.454299114121939] , 
['Aker', 'AKER', 514.200494811093, 40393931997, 43.4343354806452, 0.548092886866901] , 
]
```

```{python}
stocks[1]
```

Som du ser, så består listen av tolv rader og seks kolonner. Dette er altså en 12x6-matrise. Den kan enkelt konverteres til en numpy-matrise med funksjonen `np.array()` slik som her:

#### Eksempel 14:

```{python}
#| scrolled: true
stocks_np = np.array(stocks)
```

```{python}
type(stocks_np)
```

Her ser vi at datatypen er `numpy.ndarray`, som vi nevnte over.

```{python}
stocks_np
```

Listen er nå lagret som en numpy 12x6-matrise i objektet `stocks_np`. Vi kan imidlertid ikke utføre noen matematiske beregninger slik denne matrisen står, fordi alle tall er i tekstformat. Som vi har sett tidligere går det bare an å regne med `float`, `int` og `bool`. At det er tekst ser vi ved at det er enkle anførselstegn `'` rundt alle elementene. 

Heldigvis er det veldig enkelt å hente ut informasjon fra numpy-matriser, fordi mulighetene til å skjære utsnitt er langt større enn for vanlige lister. Numpy-lister kan nemlig skjæres i flere dimensjoner. 

I motsetning til vanlige lister, kan vi for eksempel velge ut kolonner. I en liste av lister velger du, som vi har sett, rad 2 og kolonne 0 med `stocks[2][0]`. Med numpy-matriser separerer du de to indeksene med et komma, `stocks[2,0]`.

Men enda viktigere, du kan velge alle elementer ved å sette inn kolon `:` i stedet for tall. Dermed kan du velge hele kolonne 0 med `stocks_np[:,0]`.

Her er vi mest interessert i de to siste kolonnene. Det er disse som inneholder tall. For å plukke ut disse velger vi alle radene (`:`) og alle kolonnene fra og med kolonne 2 (`2:`). Da får vi

#### Eksempel 15:

```{python}
stocks_np[:,2:]
```

Sist i matrisen over, står det `dtype='<U32'`. Det betyr at dette er tekstrenger på 32 eller færre tegn. Vi må imidlertid ha dette over i tallformat for å kunne jobbe med det. Det gjør vi slik:

#### Eksempel 16:

```{python}
stocks_numbers = np.array(stocks_np[:,2:], dtype = float)
stocks_numbers
```

Når vi konverterte listen til en `ndarray`, så brukte vi altså funksjonen `np.array()`, slik som i Eksempel 14. Men denne gangen legger vi til det valgfrie argument `dtype=float` for å eksplisitt gi beskjed om at vi ønsker strengene konvertert til flyttall. 

Nå kan vi begynne å bruke tallene. For eksempel kan vi se grafisk om det er en sammenheng mellom gjeldsgrad og pris-inntjeningstraten (PE). Dette er de to siste kolonnene i datamatrisen:

#### Eksempel 17:

```{python}
from matplotlib import pyplot as plt

fig,ax = plt.subplots()
ax.set_ylabel('PE')
ax.set_xlabel('gjeldsrate')
ax.scatter(stocks_numbers[:,-1], stocks_numbers[:,-2])
plt.grid(True)

plt.show()
```

Ser du en sammenheng?

Det er også enkelt å regne med Numpy. Vi kan bruke alle de vanlige regneartene med numpy-matriser:

```{python}
a = np.array([1,5,6,3])
b = np.array([23,15,2,10])

print(a+b)
print(a-b)
print(a*b)
print(a/b)
print(a**3)
print(a**0.5) #Kvadratroten
```

# Oppslag

Et oppslag, eller *dictionary* har symbol `dict` i Python. Dette er en datastruktur der hvert element ikke identifiseres med hvor det er plassert, men med et nøkkelord (`key`). Å bruke oppslag i stedet for lister gjør ofte koden mer lesbar. Det finnes to måter å lage oppslag på; enten ved å bruke funksjonen `dict()`:

#### Eksempel 18:

```{python}
# Definere en tom dictionary kalt a
a = dict()

# Gjeldsrate er i siste kolonne av stocks_numbers ndarray, altså indeks '-1'
a['gjeldsrate'] = stocks_numbers[:,-1]

# PE er i nest siste kolonne av stocks_numbers ndarray, altså indeks '-2'
a['PE'] = stocks_numbers[:,-2]

print(a)
print(type(a))
```

```{python}
a['gjeldsrate']
```

Som vi ser, blir dette et objekt av type `dict`. Alternativt kan vi definere elementer inne i en krølleparentes på formen `{nøkkel: objekt}`, slik som dette:

```{python}
b={
    'gjeldsrate':stocks_numbers[:,-1],
    'PE':stocks_numbers[:,-2], 
  }

print(type(b))
```

Her er det altså to elementer med nøkler `'gjeldsrate'` og `'PE'`, og tilhørende objekter fra `stocks_numbers`. 

Vi legger merke til at dette også er en objekt av type `dict`. Med oppslag blir det enklere å bruke variablene, siden vi kan referere til dem med navn i stedet for indeks. Her er plottet i Eksempel 17 gjort med oppslag:

#### Eksempel 19:

```{python}
#| scrolled: true
plt.ylabel('PE')
plt.xlabel('gjeldsrate')
plt.scatter(a['gjeldsrate'], a['PE'])
```

Når du først har laget en dict, er det enkelt å legge til nye elementer. Det gjør du enkelt ved å bruke en nøkkel som ikke finnes, for eksempel `'Pris'`, og dette elementet lik ønsket objekt:

#### Eksempel 20:

```{python}
a['Pris']=stocks_numbers[:,0]
plt.ylabel('Pris')
plt.xlabel('gjeldsrate')
plt.scatter(a['gjeldsrate'], a['Pris'])
```

`dict`-objektet er helt sentralt i selve byggeklossene til Python. Alle variabler du lager er faktisk elementer i to `dict` som du kan få frem med funksjonene `locals()` og `globals()`, som kaller de lokalt og globalt definerte variablene i miljøet du befinner deg. Dette eksemplet viser at objektet `stocks` som vi har definert i Eksempel 13, er identisk med elementet `'stocks'` i `locals()`.

#### Eksempel 21:

```{python}
locals()['stocks']==stocks
```

Vi ser at disse objektene egentlig er det samme, ved at den logiske testen om disse er like, returnerer sann (`True`).

# Oppgaver

Det er enkelt å konvertere en pandas dataramme til numpy. Vi skal bruke et datasett som heter 'schooling-gdp.csv', som er en Excel-fil. Vi henter inn dataene og konverterer dem til numpy slik:

```{python}
import pandas as pd
```

```{python}
# Dette kan dere kjøre som det er, vi skal se mer på pandas i neste forelesning!
df = pd.read_csv('https://raw.githubusercontent.com/uit-bed-1304-h25/uit-bed-1304-h25.github.io/refs/heads/main/data/schooling-gdp.csv')

# Gjør om en pandas dataframe til numpy
numpy_data = df.to_numpy()

# Dette er dataene vi skal jobbe med i oppgaver. Mer om Pandas og databehandling i neste forelesning
numpy_data
```

1. Bytt ut navnet til "Ireland" med "Republic of Ireland" og "United States" med "United States of America"


2. Print data for "Luxembourg"


3. Print data for "Liberia" ved å referere til nest siste element. 


4. Print BNP per capita for de tre siste elementene i `schooling` (ligger i kolonne med indeks 2)


5. Print BNP per capita for de tre siste elementene i `schooling` men hent kolonnen ved å refere til tredje siste kolonne. 


6. Plukk ut de tre siste kolonnene i `schooling`, som representerer BNP per capita, skolegang og befolkning, og konverter dem til datatype `float`. 



7. Lag et oppslag (dictionary) med de tre siste kolonnene og passende navn som nøkler. Kall det `schooling_dict`. 


8. Lag en ny variabel i oppslaget med navn "Total schooling" som er produktet av skolegang og befolkning.


9. Lag en ny variabel "Total GDP" som er produktet av BNP per capita og befolkning. 


10. Lag et scatterplot med de to variablene du nettopp lagde. 


11. Lag plottet over, men konverter variablene med np.log()


12. Lag en ny variabel "GDP per schooling" som er BNP per capita delt på skolegang.


13. Lag et liggende stolpediagram med navn på land og "GDP per schooling". Du bruker da funksjonen `plt.barh` på denne måten:
```
plt.barh(names,values)
```
Hvor `names` er en liste med navnene og `values` er de tilhørende verdiene. 



14. Dette blir ikke pent. Velg kun de 20 første landene, og forsøk på nytt. 


15. med argsort får du rangeringen til etter en sortering. Her er rangeringen for "GDP per schooling"


`[::-1]` til slutt sørger for å reversere sorteringen. Legg referansen til soreringen inn i variabelen `sorted`, og lag diagrammet på nytt med sorterte verdier. Om du har en numpy-liste a, kan du velge de sorterte verdiene med `a[sorted]`

Lag

a) et nytt diagram med alle landene og

b) et diagram med de 20 øverste.

c) et diagram med de 20 nederste




